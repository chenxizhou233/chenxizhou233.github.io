<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>烈日灼心观后感</title>
    <link href="/posts/465525c9.html"/>
    <url>/posts/465525c9.html</url>
    
    <content type="html"><![CDATA[<p>之前因为这是邓超的电影所以一直没看（小孩子是这样的）。今晚正好没啥事，补一补。</p><p>整部片子给人的感觉就是很扎实，很有真实感。最能体现的大概是片尾真凶陈述的时候和邓超在天台被捕后被问“你后悔吗”和探监的时候被问“还有什么想说的吗”的两次沉默。那个神情和语气，那种千言万语不知从何处说起，都被真真切切地演出来了。</p><p>整体的观看体验十分连贯，故事情节紧凑，基本没有闲笔，一直在推剧情。观影过程中只看了三四次进度条，舒服。</p><p>还有就是段和邓去接小鱼的那段对手戏，在开头就把“可能暴露”这件事给摆了出来。之后的剧情都是在这个高压前提下进行的。所以观看的时候很多看似寻常的情节都带上了一层不同的意义，也是很特别的观影体验。</p><p>总之还是很后悔当时就因为一个演员没去电影院里看这个。不敢想象开头那两幕雨中情节在大银幕上看和听雨落到塑料布上的声音会有多爽。哎，时间一去不复返啊，就像我无忧无虑的小学生活，6块电影票和当时还活着的银基购物城和老大上海城。哎。</p>]]></content>
    
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MathI</title>
    <link href="/posts/14072394.html"/>
    <url>/posts/14072394.html</url>
    
    <content type="html"><![CDATA[<h2 id="differentiable">Differentiable</h2><h3 id="local">“Local”</h3><p>Formally: <spanclass="math inline"><em>f</em>(<em>x</em>) ≤ <em>f</em>(<em>x</em><sub>0</sub>), <em>x</em> ∈ <em>I</em> ∩ (<em>x</em><sub>0</sub> − <em>δ</em>, <em>x</em><sub>0</sub> + <em>δ</em>)</span>,then we have a local maximum</p><p>Local的定义就是用 <spanclass="math inline"><em>δ</em> − <em>ϵ</em></span>定义的<strong>一段小区</strong>(邻域)间上的max。</p><p>考察的时候只用考虑<spanclass="math inline"><em>x</em><sub>0</sub></span>的去心邻域，因为由lim的性质，<spanclass="math inline"><em>x</em><sub>0</sub></span>永远不会被取到。</p><p>名词：extremum：max or min</p><p>local extremum 不是 critical point：not differentiable.</p><p><strong>证明</strong>：极值点导数为0</p><p>从两面夹。假设极大值点为<spanclass="math inline"><em>x</em><sub>0</sub></span>，f<em>Differentiable</em>，有：</p><p><spanclass="math display"><em>f</em>(<em>x</em><sub>0</sub> + <em>h</em>) ≤ <em>f</em>(<em>x</em><sub>0</sub>)   for|<em>h</em>| &lt; <em>δ</em></span></p><p>由导数的定义，我们有:</p><p><span class="math display">$$    f'(x_0)=\lim\limits_{h\to 0}\frac{f(x_0+h)-f(x_0)}{h}$$</span></p><p>分别取<spanclass="math inline"><em>h</em> &gt; 0, <em>h</em> &lt; 0</span>，有：</p><p><span class="math display">$$    \lim\limits_{h\to 0}\frac{f(x_0+h)-f(x_0)}{h} \le 0 \qquad\lim\limits_{h\to 0}\frac{f(x_0+h)-f(x_0)}{h} \ge 0$$</span></p><p>同时存在，因此<spanclass="math inline"><em>f</em><sup>′</sup>(<em>x</em><sub>0</sub>)</span>只能取0。</p><h2 id="mean-value-theorems">Mean Value Theorems</h2><p>都是在闭区间[a,b]上连续，在开区间(a,b)上可导。</p><h3 id="rolles-theorem">Rolle’s theorem</h3><p>分类讨论的力量。</p><p>在<span class="math inline">[<em>a</em>, <em>b</em>]</span>上有<spanclass="math inline"><em>f</em></span>定义，有<spanclass="math inline"><em>f</em>(<em>a</em>) = <em>f</em>(<em>b</em>)</span>，则必有一点<spanclass="math inline"><em>f</em><sup>′</sup>(<em>c</em>) = 0, <em>c</em> ∈ [<em>a</em>, <em>b</em>]</span></p><p>考虑以下三种 <spanclass="math inline"><em>x</em><sub><em>m</em></sub>, <em>x</em><sub><em>M</em></sub></span>分布的情况。</p><ol type="a"><li><spanclass="math inline"><em>x</em><sub><em>m</em></sub> ∈ (<em>a</em>, <em>b</em>)</span>，则这一点为<spanclass="math inline"><em>c</em></span></li><li><spanclass="math inline"><em>x</em><sub><em>M</em></sub> ∈ (<em>a</em>, <em>b</em>)</span>，则这一点为<spanclass="math inline"><em>c</em></span></li><li>都不在，那<spanclass="math inline">[<em>a</em>, <em>b</em>]</span>上<spanclass="math inline"><em>f</em></span>只能为常值函数，自然成立</li></ol><h3 id="lagrange-mean-value-theorem">(Lagrange) Mean Value Theorem</h3><p>构造 <spanclass="math inline">$h(x)=f(x)-\left(\frac{f(b)-f(a)}{b-a}\right)(x-a)$</span></p><p>应用Rolle’s Theorem. 必有 <spanclass="math inline"><em>h</em><sup>′</sup>(<em>x</em>) = 0</span>，即<span class="math inline">$f'(x)=\frac{f(b)-f(a)}{b-a}$</span></p><h3 id="cauchys-mvt">Cauchy’s MVT</h3><p>f，g在<spanclass="math inline">[<em>a</em>, <em>b</em>]</span>连续可导 <spanclass="math inline">[<em>f</em>(<em>b</em>) − <em>f</em>(<em>a</em>)]<em>g</em><sup>′</sup>(<em>c</em>) = [<em>g</em>(<em>b</em>) − <em>g</em>(<em>a</em>)]<em>f</em><sup>′</sup>(<em>c</em>)</span></p><h2 id="talyors-theorem">Talyor’s Theorem</h2><h3 id="peano余项">Peano余项</h3><p>定性分析， <span class="math inline">$\lim\limits_{x\tox_0}\frac{R(x)}{(x-x_0)^n}=0$</span></p><h3 id="lagrange-cauchy余项">Lagrange &amp; Cauchy余项</h3><p>定量分析工具：</p><p><span class="math display">$$    R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \text{ and }R_n(x)=\frac{f^{(n+1)}}{n!}(x-\xi)^n\cdot(x-x_0)$$</span></p><p>where <span class="math inline"><em>ξ</em></span> is between <spanclass="math inline"><em>x</em></span> and <spanclass="math inline"><em>x</em><sub>0</sub></span></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prog1-Part2</title>
    <link href="/posts/622f6855.html"/>
    <url>/posts/622f6855.html</url>
    
    <content type="html"><![CDATA[<p>感觉自己下半学期学的有点问题，写点笔记复习一下</p><p>感觉下半学期的重点是编译原理，主要可以分为这么几个部分：</p><ol type="1"><li>Lexer: 把程序转化为Token</li><li>Parser: 把Token转化为语言的数据类型</li><li>Elaborator: 静态类型检查</li><li>Evaluator: 求值</li></ol><p>自我感觉1.3.4.掌握的还行，Paser还是有点不明白。</p><p>以及3.4.的Derivation Tree还要再记一下表示方法。</p><p>编译原理这一块还是先拿课上的顺序进行整理：3.4.1.2.</p><h2 id="编译原理">编译原理</h2><h3 id="elaborator静态类型检查">Elaborator——静态类型检查</h3><p>作为人类，可能能一步一步推导类型，但怎么让计算机做呢？</p><p>仔细观察（bushi），可以抽象出来几条规则，这里拿latex抄一遍：</p><p>渲染有问题，直接用图片了QwQ</p><img src="/posts/622f6855/SS.png" class="" title="Static Semantics"><p>这个还是比较好理解的，因为不涉及环境的变更，一点一点推导下去就可以了。</p><h3 id="evaluator动态求值">Evaluator——动态求值</h3><p>这里涉及环境的变更，所以语法上有些地方要注意。</p><img src="/posts/622f6855/DApp.png" class="" title="DApp"><ol type="1"><li>函数要写成Tuple的形式</li><li>新的环境要在最后表示出来</li></ol><img src="/posts/622f6855/DAbs.png" class="" title="DAbs"><p>函数在Abs时候要写成Tuple形式。</p><h3 id="lexertoken化">Lexer——Token化</h3><p>这个没啥难的，直接字符串explode后match就可以</p><h3id="parser把token处理为eval和elab能处理的形式">Parser——把Token处理为Eval和Elab能处理的形式</h3><p>这里用的是Recursively Descending Parser主要思想就是先处理优先级低的，然后一步一步向下处理。这里用到了OCaml一个制造相互使用的函数的语法糖：and。就是可以前面先用这个函数，然后and 函数名=…补上。</p><p>这里复习一下我一分不得的Mini Test题目：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs OCaml"><span class="hljs-keyword">type</span> token=<span class="hljs-type">HE</span>|<span class="hljs-type">HO</span>|<span class="hljs-type">LP</span>|<span class="hljs-type">RP</span>|<span class="hljs-type">SIM</span><br>;;<br><span class="hljs-keyword">type</span> exp=<span class="hljs-type">He</span>|<span class="hljs-type">Ho</span>|<span class="hljs-type">Sim</span> <span class="hljs-keyword">of</span> exp*exp<br>;;<br><span class="hljs-keyword">type</span> cexp ts=<br><span class="hljs-keyword">match</span> pty ts <span class="hljs-keyword">with</span><br>| t1, <span class="hljs-type">SIM</span> :: ts = <span class="hljs-keyword">let</span> t2,ts = cexp ts <span class="hljs-keyword">in</span> (<span class="hljs-type">Sim</span>(t1,t2),ts)<br>| p-&gt;p<br><span class="hljs-keyword">and</span> pty = <span class="hljs-keyword">function</span><br>| <span class="hljs-type">HE</span>::ts -&gt; (<span class="hljs-type">He</span>,ts)<br>| <span class="hljs-type">HO</span>::ts -&gt; (<span class="hljs-type">Ho</span>,ts)<br>| <span class="hljs-type">LP</span>::ts -&gt; <br>        <span class="hljs-keyword">let</span> t1,ts = cexp ts <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">let</span> ts = expect <span class="hljs-type">RP</span> ts <span class="hljs-keyword">in</span><br>        (t1,ts)<br>| _-&gt;failwith <span class="hljs-string">&quot;Not Valid&quot;</span><br></code></pre></td></tr></table></figure><p>核心还是每次解析的时候尝试看看下层还有没有可以解析的，然后一层一层向下。</p><p>核心就是Grammar，对每个非终结符总结一个替换方式然后按优先级逐个应用。</p><h2 id="形式化的递归表达">形式化的递归表达</h2><p>现在课上在讲这个，顺手写一下吧。</p><h3 id="递归式的一种表示方法">递归式的一种表示方法</h3><p>e.g.</p><p><spanclass="math inline"><em>F</em><em>i</em><em>b</em>(<em>x</em>) = IF<em>x</em> &lt; 2 THEN <em>x</em> ELSE<em>F</em><em>i</em><em>b</em>(<em>x</em> − 1) + <em>F</em><em>i</em><em>b</em>(<em>x</em> − 2)</span></p><p>可以表示为 <span class="math inline">IF <em>x</em> &lt; 2 THEN ⟨⟩ELSE ⟨<em>x</em> − 1, <em>x</em> − 2⟩</span></p><h3 id="递归关系">递归关系</h3><p>刚才的柿子中，<span class="math inline">⟨⟩</span> 中的东西叫PrecedentArgument. 如果我们把当前参数和PrecedentArgument中间连一条有向边，就构成的一个递归关系R。</p><p>可以和之前的Termination Relation联系起来：你能terminate，这个递归才能结束。怎么判断能否Terminate呢，看这个function能不能在某种encoding下countable。</p><h3id="证明函数定义和数学上的函数表达的是一个东西"><em>证明</em>函数定义和数学上的函数表达的是一个东西</h3><p>这一部分主要是数学上的证明，跟编程知识就没啥关系了。</p><p>但是minitest里给出了需要的证明方式：</p><h4 id="证明dom-somethingsubseteqdom-f">1.证明Dom something<spanclass="math inline">⊆</span>Dom f</h4><p>给出Termination Function， 证明两个Dom都对这个function terminate，所以有这个关系</p><h4 id="证明数学上一致">2.证明数学上一致</h4><p>对每个条件分支，做一下和Mathematical induction类似的变形。</p><h3 id="structural-induction">Structural Induction</h3><p>Given a claim, for each possible arg, make the claim a inductionform.</p><h3 id="解题过程的注意事项">解题过程的注意事项：</h3><p>首先，起手式是固定的，以List相关内容为例：</p><blockquote><p>Let <span class="math inline"><em>X</em></span> be an arbitrary yetfixed type, we show the <spanclass="math inline">∀<em>x</em><em>s</em> ∈ ℒ(<em>X</em>), <em>y</em><em>s</em> ∈ ℒ(<em>X</em>), ...(theclaim) by structural induction on <em>x</em><em>s</em></span></p></blockquote><p>然后开始induction，先证基本类型，再证induction的part。重点就是要写得尽可能详细，每一步都要有出处，常见的有：</p><ul><li>arithmetic</li><li>a=b+c</li><li>IH(induction hypothesis)</li><li>Definition of function</li><li>…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ITCS</title>
    <link href="/posts/85db524f.html"/>
    <url>/posts/85db524f.html</url>
    
    <content type="html"><![CDATA[<p>快到期末周了，为自己的Cheat Sheet做点准备</p><h2 id="naive-set-theory">Naive Set Theory</h2><p>感觉唯一要看的是两个集合的power和一个证明过程。</p><p>CaO，一翻Slide发现还有几个定义要说。</p><h3 id="几个定义">几个定义</h3><p>$={X $ <spanclass="math inline"> ⊆ <em>A</em> : |<em>X</em>| = <em>k</em>}</span></p><p><spanclass="math inline"><em>B</em><sup><em>A</em></sup> = {<em>f</em> : <em>A</em> → <em>B</em>}</span></p><p><span class="math inline"><em>a</em>  <em>R</em>  <em>b</em></span>infixnotation for <spanclass="math inline">(<em>a</em>, <em>b</em>) ∈ <em>R</em></span></p><h3 id="一个证明">一个证明</h3><p><font color='red'>Theorem</font>: For every set <spanclass="math inline"><em>A</em></span> it is <strong>not</strong> thecase that <spanclass="math inline">|2<sup><em>A</em></sup>| ≤ |<em>A</em>|</span></p><p>Proof: <font color=#39c5bb><spanclass="math inline"><em>h</em></span></font><spanclass="math inline"> : →</span><font color=#39c5bb><spanclass="math inline">2<sup><em>A</em></sup></span></font>, we need toshow that <font color=#39c5bb><spanclass="math inline"><em>h</em></span></font> is not a surjection.</p><p>i.e. given <span class="math inline"><em>h</em></span> we need tofind some <font color=#39c5bb><spanclass="math inline"><em>Δ</em><sub><em>h</em></sub> ∈ 2<sup><em>A</em></sup></span></font>so that</p><p><spanclass="math display">∀<em>a</em> ∈ <em>A</em> : <em>h</em>(<em>a</em>) ≠ <em>Δ</em><sub><em>h</em></sub></span></p><p>Use <spanclass="math inline"><em>Δ</em><sub><em>h</em></sub> = {<em>a</em> ∈ <em>A</em>|<em>a</em> ∉ <em>h</em>(<em>a</em>)}</span></p><p>For every <span class="math inline"><em>a</em> ∈ <em>A</em></span>the sets <span class="math inline"><em>h</em>(<em>a</em>)</span> and<span class="math inline"><em>Δ</em><sub><em>h</em></sub></span> differin element <span class="math inline"><em>a</em></span>.</p><h3 id="经典方法">经典方法</h3><p>康托对角化</p><h2 id="words-strings-language">Words, Strings, Language</h2><h3 id="一些定义">一些定义</h3><p><span class="math inline"><em>Σ</em>…</span> finitset “Alphabet”</p><p><span class="math inline"><em>Σ</em><sup><em>k</em></sup>…</span>ordered k-tuples over <span class="math inline"><em>Σ</em></span> <spanclass="math inline">  <em>w</em> = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>k</em></sub>)</span></p><p><span class="math inline">      </span>words of length <spanclass="math inline"><em>k</em>  </span> <spanclass="math inline"><em>w</em> = <em>a</em><sub>1</sub><em>a</em><sub>2</sub>…<em>a</em><sub><em>k</em></sub>   |<em>w</em>| = <em>k</em></span></p><p><span class="math inline"><em>ϵ</em>   </span> empty word</p><p><spanclass="math inline"><em>Σ</em><sup>*</sup>  <em>Σ</em><sup>+</sup></span>all finite string and all finite non-empty string</p><p><span class="math inline">#<sub><em>a</em></sub>(<em>w</em>):</span>a在w中的出现次数</p><p><span class="math inline"><em>L</em> ⊂ <em>Σ</em><sup>*</sup>…</span>“language” over <span class="math inline"><em>Σ</em></span></p><h3 id="图灵机入门">图灵机入门</h3><p>三类： FA，PDA，TM</p><p>分别对应Chomsky的 Regular grammar，Context free grammar和UnrestrictedGrammar</p><h2 id="fa">FA</h2><h3 id="记号">记号</h3><p><spanclass="math inline"><em>Σ</em>  <em>Q</em>  <em>s</em> ∈ <em>Q</em>  <em>F</em> ⊂ <em>Q</em>  <em>Δ</em> ⊂ ((<em>Q</em> × <em>Σ</em>) × <em>Q</em>)</span></p><p>分别代表： 字符集 状态集 起始状态 终止状态集Configuration(状态转移路径集？)：(当前状态，转移字符，转移后状态)</p><p>Computing step relation <spanclass="math inline">⊢<sub><em>M</em></sub></span> on <spanclass="math inline"><em>K</em><sub><em>M</em></sub></span></p><p><spanclass="math inline">∀<em>q</em> ∈ <em>Q</em>, <em>a</em> ∈ <em>Σ</em>, <em>u</em> ∈ <em>Σ</em><sup>*</sup> : (<em>q</em>, <em>a</em><em>u</em>)⊢<sub><em>M</em></sub>(<em>q</em><sup>′</sup>, <em>u</em>)iff(<em>q</em>, <em>a</em>, <em>q</em><sup>′</sup>) ∈ <em>Δ</em></span></p><p><span class="math inline">⊢<sub><em>M</em></sub><sup>*</sup></span>on <span class="math inline"><em>K</em><sub><em>M</em></sub></span></p><p>当有一个计算路径时，直接前面起始state，后面终止state.</p><p>分为Deterministic 和 Non deterministic.</p><h3 id="continuous-language">Continuous Language</h3><p>是这门课教授为了教学创造的概念，但给的Lemma是通用的</p><p>定义为 <spanclass="math inline"><em>F</em><sub><em>L</em></sub>(<em>w</em>) = {<em>a</em>|<em>a</em> ∈ <em>Σ</em>, <em>w</em><em>a</em> ∈ <em>L</em>}</span></p><blockquote><h4 id="theoremmyhill-nerode">Theorem(Myhill-Nerode)</h4><p>L DFA language <spanclass="math inline"> ⇔ ℱ<sub><em>L</em></sub></span> is finite</p></blockquote><p>一般反着用：</p><p><span class="math inline">ℱ<sub><em>L</em></sub></span><strong>not</strong> finite <span class="math inline">⟹</span> L<strong>not</strong> DFA-language.</p><p>证非REG可以找一组 <spanclass="math inline">{<em>w</em><sup>(<em>i</em>)</sup> ∈ <em>Σ</em><sup>*</sup>}</span>s.t <spanclass="math display"><em>F</em><sub><em>L</em></sub>(<em>w</em><sup>(<em>i</em>)</sup>) ≠ <em>F</em><sub><em>L</em></sub>(<em>w</em><sup>(<em>j</em>)</sup>)for<em>i</em> ≠ <em>j</em></span></p><p>之后有Pumping Lemma了其实就没那么常用了。后面也知道DFA-language就是Regular Language</p><h3 id="dfs-minimization">DFS Minimization</h3><p>暴力算法：先按终态和末态分，然后每次检查每个划分中是否每个元素在每个可能输入下都会保持在同一分区，如果不是，将输入后的转移结果相同的状态再划分到一起</p><h3 id="nfa转dfa">NFA转DFA</h3><p>因为我一直和最小化搞混，就一起写了。 子集构造好难。</p><blockquote><p>定义：子集构造就是先对Q做一个powerset，然后将里面的元素作为新的Q’.再按这些子集之间的转移关系建立新的DFA。</p></blockquote><p>哎，期中考试这题一分不得。麻了。</p><h3 id="pumping-lemma">Pumping Lemma</h3><blockquote><p>正着的形式： L REG <span class="math inline">⟹</span> <spanclass="math inline">∃<em>N</em> ∈ ℕ : ∀<em>u</em><em>v</em><em>w</em> ∈ <em>L</em>   ∃partition<em>v</em> = <em>x</em><em>y</em><em>z</em>   : ∀<em>i</em> ∈ ℕ : <em>u</em><em>x</em><em>y</em><sup><em>i</em></sup><em>z</em><em>w</em> ∈ <em>L</em></span></p><p><spanclass="math inline">          |<em>v</em>| ≥ <em>N</em>        with0 &lt; |<em>y</em>| ≤ <em>N</em></span></p></blockquote><p>因为它是必要不充分的，一般反着用判断非REG： <em>Remark: 对于 over<strong>一个字母</strong>的language，fulfilling the pumping lemma is充要的</em> （我在写什么，蚌）</p><blockquote><p><spanclass="math inline">∀<em>N</em> ∈ ℕ : ∃<em>u</em><em>v</em><em>w</em> ∈ <em>L</em>   : ∀partition<em>v</em> = <em>x</em><em>y</em><em>z</em>   : ∃<em>i</em> ∈ ℕ : <em>u</em><em>x</em><em>y</em><sup><em>i</em></sup><em>z</em> ∉ <em>L</em></span></p><p><spanclass="math inline">          |<em>v</em>| ≥ <em>N</em>        with0 &lt; |<em>y</em>| ≤ <em>N</em></span></p></blockquote><p>可以用一种“玩游戏”的说法解释一下全称量词：</p><p><span class="math inline">∀</span>对手选，自己无法控制 <spanclass="math inline">∃</span>自己选</p><ol type="1"><li>对手选<span class="math inline"><em>N</em></span>，你母鸡</li><li>自己从L中选一个词，并自己确定uvw的划分，<spanclass="math inline">|<em>v</em>| ≥ <em>N</em></span></li><li>对手选择v=xyz的划分方法，保证 <spanclass="math inline">0 &lt; |<em>y</em>| ≤ <em>N</em></span></li><li>自己选择<span class="math inline"><em>i</em></span>使<spanclass="math inline"><em>u</em><em>x</em><em>y</em><sup><em>i</em></sup><em>z</em><em>w</em></span>不在L中</li></ol><p>这样就可以证L非REG了。</p><h2 id="pda">PDA</h2><h3 id="notations">Notations</h3><p>比FA多了</p><ol type="1"><li>$:栈的起始符号</li><li><span class="math inline"><em>Γ</em></span>:栈的字符集</li><li><span class="math inline"><em>Δ</em></span>多一个对栈的操作，变为</li></ol><h3 id="pumping-lemma-for-cfl">Pumping Lemma for CFL</h3><p>相似地，对于Context Free Language， 我们也有相似的Grammar。</p><p>基本思想可以近似地理解为因为生成规则是finite的，因此想要生成长字符串必定能有某种重复规律。</p><p>Formally:</p><blockquote><p><spanclass="math inline">∃<em>z</em> ∈ <em>L</em>, |<em>Z</em>| ≥ <em>N</em></span><span class="math inline">∀</span> partition z=uvwyz with <spanclass="math inline">|<em>v</em><em>w</em><em>x</em>| ≤ <em>N</em>, |<em>v</em><em>x</em>| &gt; 0</span><span class="math inline">∃<em>i</em> s.t.<em>u</em><em>v</em><sup><em>i</em></sup><em>w</em><em>y</em><sup><em>i</em></sup><em>z</em> ∉ <em>L</em></span></p></blockquote><p>主要是第二步要分类讨论，覆盖所有可能情况。</p><h2 id="reducibility">Reducibility</h2><!-- 梦到哪个写哪个（ --><p>不formal的定义：A<span class="math inline">≼</span>B:B能解决A。B至少和A一样难。</p><blockquote><p>经典停机问题解法：SAM<span class="math inline">≼</span>HALT SAM(M):if not HALT(M,|M|): reject else if M(|M|): accept; else: reject.这样就构造出了SAM。而SAM undecidable。所以HALT也undecidable.</p></blockquote><p>这样我们就证明了HALT undecidable.</p><p>Formal的定义：</p><p><spanclass="math inline">∀<em>A</em>, <em>B</em> ⊆ <em>Σ</em><sup>*</sup>, ∃everywhere computable<em>f</em> : <em>A</em> → <em>B</em>, ∀<em>x</em> ∈ <em>A</em>, <em>f</em>(<em>x</em>) ∈ <em>B</em></span></p><p>虽然不知道怎么用，但还是记一下。</p><h2 id="复杂度类">复杂度类</h2><p>这是前两周的主要内容。记录一下。</p><h3 id="基本符号表示">基本符号表示</h3><p>NSAPACE，DSAPCE，NTIME，DTIME：分别代表non-det和det的<code>State graph中从$s\in S \to f\in F$的路径上thickness的最大值</code>和<code>...走过边数的最大值</code>。</p><h3 id="几个经典的复杂度类">几个经典的复杂度类</h3><p><spanclass="math display"><em>P</em> = ⋃<sub><em>k</em> &gt; 1</sub><em>D</em><em>T</em><em>I</em><em>M</em><em>E</em>(<em>n</em><sup><em>k</em></sup>)</span></p><p><spanclass="math display"><em>N</em><em>P</em> = ⋃<sub><em>k</em> &gt; 1</sub><em>N</em><em>T</em><em>I</em><em>M</em><em>E</em>(<em>n</em><sup><em>k</em></sup>)</span>同理可得 PSAPCE和NPSPACE。 还有两个特殊的：</p><p><spanclass="math display"><em>L</em> = DSPACE(log <em>n</em>)，<em>N</em><em>L</em> = NSAPCE(log <em>n</em>)</span></p><p>他们之间的关系是 <spanclass="math display"><em>L</em> ⊆ <em>N</em><em>L</em> ⊆ <em>P</em> ⊆ <em>N</em><em>P</em> ⊆ <em>D</em><em>S</em><em>P</em><em>A</em><em>C</em><em>E</em> = <em>N</em><em>S</em><em>P</em><em>A</em><em>C</em><em>E</em></span></p><h2 id="p-reducible">P-reducible</h2><h3 id="definition">Definition</h3><p>首先引入一个polynomial reduction。 其实就是把everywherecomputable的function f加了个“能在polynomial时间内算出”。符号长<spanclass="math inline">≼<sub><em>p</em></sub></span>这样。</p><h3 id="np-hard-np-completeness">NP-hard &amp; NP-completeness</h3><p>NP-hard的定义：</p><blockquote><p>For language <span class="math inline">S</span>, <spanclass="math inline">∀<em>L</em> ∈ NP, <em>s</em>.<em>t</em>.<em>L</em>≼<sub><em>p</em></sub><em>S</em></span>,then S is <span class="math inline">NP-hard</span>。</p></blockquote><p>NP-complete的定义：</p><blockquote><p>…, S<span class="math inline"> ∈ NP</span></p></blockquote><h3 id="几个具体">几个具体🌰</h3><p><span class="math inline">MERF</span>:多变量SAT <spanclass="math display">P-UNIV≼<sub><em>p</em></sub>MERF≼<sub><em>p</em></sub>SMERF≼<sub><em>p</em></sub>SAT≼<sub><em>p</em></sub>3-SAT≼<sub><em>p</em></sub>CLIQUE</span>同时还有： <spanclass="math display">3-SAT≼<sub><em>p</em></sub>3COLORABILITY</span>这个Reduction的Idea是我们把 对于<spanclass="math inline">SAT≼<sub><em>p</em></sub>3-SAT</span>这一块，记录一下教材上的证法：</p><blockquote><p>对于一个柿子，比如 <span class="math inline">$p=a\land\overline{b}\land \overline{c}\land d$</span>我们可以引入一个新变量<spanclass="math inline"><em>z</em></span>,构造另外两个柿子<spanclass="math inline">$p_1=a\land \overline{b}\landz,p_2=\overline{c}\land d\land \overline{z}$</span>。 保证只有<spanclass="math inline"><em>p</em></span>成立时，两个柿子才成立，viceversa。 这个构造可以成立的原因有两个：1.这个构造把柿子拆成了两部分，分别和原柿子相符。2.因为一个z取反了，另一个没有，所以整个柿子是否satisfiable与<spanclass="math inline"><em>z</em></span>无关。 因此这个构造可行。</p></blockquote><!-- TODO:加上HAMP相关的东西，也是这一周的作业 -->]]></content>
    
    
    
    <tags>
      
      <tag>理论计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东方学读书笔记</title>
    <link href="/posts/2fd61a7e.html"/>
    <url>/posts/2fd61a7e.html</url>
    
    <content type="html"><![CDATA[<h2 id="绪论部分">绪论部分</h2><p>几个前提：</p><ul><li>东西方并不是自然的存在，不仅存在于自然中</li><li>东方本质上不存在是错的</li><li>聊东方学不能只聊东方学。不研究双方力量关系，权力结构，观念等就无法全面认识东方学。</li><li>东方学并不只是虚妄之语，而是几个世纪以来文化和实权等的积累。</li></ul><p><strong>霸权（hegemony）</strong>：社会中总有一些文化形式对其他的文化形式可以产生支配。</p><p>为方便后文阐述，提到了当代现实的三个方面：</p><ol type="1"><li>纯粹知识与政治知识的区分：认为“纯粹”知识不政治忽视了产生知识时的政治情景-&gt;知人论世，谈论知识离不开背景</li><li>方法论：说明了主要选取英法的材料进行研究的原因与心路历程</li><li>个人层面：引用葛兰西《狱中笔记》“批判性思考的起点是认识到你到底是谁，认识到‘认识你自己’也是一种历史过程的产物”。</li></ol><p>“Sie können sich nicht vertreten, sie müssen vertreten werden”–卡尔·马克思《路易·波拿巴的雾月十八》</p><h2 id="第一章东方学的范围">第一章：东方学的范围</h2><h3 id="认识东方">1. 认识东方</h3><p>对东方的认识，是经过西方的一整套机制与方法论得以实现的，是“需要西方的正确研究的”，因而东方在出现时必定会被“某种支配性的框架所控制和表述”。</p><p>结果：二元对立，武断的描述</p><h3 id="东方化东方">2.东方化东方</h3><p>更新计划：期末考完？反正没人看。感觉《东方学》的主要内容还是东方作为一个由力量不均衡所被制造出来的概念，在合理化压迫上做出了很大的贡献。</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本剧情片二则</title>
    <link href="/posts/52d23f8f.html"/>
    <url>/posts/52d23f8f.html</url>
    
    <content type="html"><![CDATA[<p>电脑散热炸了？玩不了Dota2就只能看点电影缓解一下了QwQ。</p><p>《浮云》和《情书》这俩日本电影都挺好的，克制地表达这一块日本整的真的没得说。</p><h2 id="情书">《<ahref="https://www.bilibili.com/bangumi/play/ep424779?theme=movie&amp;from_spmid=666.7.feed.96">情书</a>》</h2><p>这部先看，所以先写这个。</p><p>整体剧情是在对未婚夫的一次祭奠活动后，女主在他的同学录中找到了未婚夫初中时的旧住址（理论上被拆了），想着两个都没了（，就写了信过去。</p><p>神奇的是，她竟然收到了回信。原因是当地还有一个和男主同名同姓（藤井树）同届的女生，而快递员正努力追求着她，于是这封信竟然真的被收到了。</p><p>之后两个人便通过信笔谈，女藤井树在信中讲了许多初中时和男树的往事，而女主那边的剧情则主要是对男主的放下和对男二的接纳，她的回信主要起到一个回信的作用（。中间因为男二的向女藤本树冒犯地写了封信要身份证复印件，女主还去找了女树，见了一面，但对方不知道。之后便是在知道所有往事后，向女树表达了感谢，断了联系。然后和男二一起去男主遇难的那座山，和之前的当事人带了一夜，互诉衷肠（？），并在第二天一早想着朝阳升起的大山呼唤お元気ですか? 完成了对逝者的放下。</p><p>除了追忆这条线，女树那边还有一个贯穿全戏的线索：感冒。其实不太理解象征义，但剧情上还是能记起来的。 &gt; 查阅<ahref="https://www.bilibili.com/opus/1069066043487420435">BiliBili</a>，得到了这条线的主要冲突：女树妈妈和爷爷的隔阂&gt; P.S.这个人写的影评不赖</p><p>这条线的主角是女树的爷爷：多年前因为儿子久感冒拖成肺炎，在大雪天把他背向医院，但没来得及，儿子先走一步了。女树妈妈认为这是爷爷不听专家一意孤行的错，与他产生隔阂，甚至在换房子这样的大事上也无视他。如今，当女树也因感冒生命垂危时，他在与妈妈的对质中报出的当年的诸多时间和细节，让妈妈也感受到了爷爷确实不是鲁莽用事，心里也一直无法实话。于是二人隔阂解开，合力将女树送到了医院。</p><p>结尾女树在当时男树执意要她帮还的追忆似水年华中看到了画有她肖像的借书卡，然后电影结束。哎，错位的爱呀。</p><p>总之整部电影情节饱满，表达克制，音画结合做的很好。非常值得一看的剧情片。</p><h2 id="浮云">《<ahref="https://www.bilibili.com/video/BV1xW38zBEp4/?spm_id_from=666.7.top_right_bar_window_history.content.click">浮云</a>》</h2><p>初次见面还是在斯特拉斯堡。当时还在考虑度过最后一点时间的办法，走着走着看到了一个电影院，有一张写着中文“浮云”的海报。可惜时间不对，现在正好电脑散热器炸了，看一看。</p><p>这部片的时代性更强一些。男女主的设定是战时被派到法属支那半岛的农林省工作人员，在哪里相识相爱。战后回到国内，努力生活。中间分分合合，最后一起去了偏远的山区，女主因病逝去，男主于痛哭与回忆中结束了电影。</p><p>感觉剧情能总结的不多，都是需要娓娓道来的时间，强烈建议亲自欣赏一下这部电影。</p>]]></content>
    
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/16107.html"/>
    <url>/posts/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/posts/1f18a9aa.html"/>
    <url>/posts/1f18a9aa.html</url>
    
    <content type="html"><![CDATA[<p>年末了，写点东西记录一下自己。说不定以后看来会很神奇XD</p><h2 id="股票投资">股票投资</h2><p>第一个想说的是股票相关的操作</p><p><strong>别买妖股，别买妖股！</strong></p><p>从知乎看到的炒股第一性原则很有意思： 你的股票准备卖给谁？</p><p>对meme股来说，随时准备抽身，当然最好还是别碰以下是几只当前持仓的股票：</p><table><thead><tr><th>名称</th><th>买入均价</th><th>数量</th><th>现价</th><th>评价</th></tr></thead><tbody><tr><td>AAPL</td><td>210.35</td><td>1</td><td>273.42</td><td>有好感就买了（</td></tr><tr><td>ATCH</td><td>1</td><td>10</td><td>0.265</td><td>妖股，曾经两倍收益，不收手就亏光QwQ</td></tr><tr><td>GOOGL</td><td>184.93</td><td>1</td><td>314.1</td><td>感觉谷歌是好公司，买就完事了</td></tr><tr><td>LKNCY</td><td>38.4</td><td>2</td><td>34.25</td><td>中概股QwQ 以及有好感就买了，小亏</td></tr><tr><td>NVS</td><td>115.77</td><td>1</td><td>138.88</td><td>生物制药龙头股，感觉生物还是有赚头的</td></tr><tr><td>TSLA</td><td>301.88</td><td>1</td><td>485.9</td><td>马斯克meme股，当时支持以下ai女友，没想到买到低点了XD</td></tr></tbody></table><p>感觉今年投资十分甚至九分的稚嫩，慢慢学吧，至少收益是正的。</p><p>p.s.12.30更新：年前美元给我拉了泡大的啊，特斯拉也小跌，哎，难评。</p><h2 id="出国留学">出国留学</h2><p>看了看之前吐的黑泥，发现想跑的意愿还是很强的。跑出来了也算好事。</p><p>总体感觉这边教学体系什么的确实会好一点，考试难度都不低，感觉无法突击，只能平时就学好。</p><p>德国这边的物价什么还好，平均算下来一个月700€，不赖，而且还住的单间。</p><p>未来的话不好说，因为德国说是Google要新建数据中心，感觉机会还是有。不过欧洲整体还是没什么发展的前景。只能再看看了。</p><p>这学期选了Programming 1，Algorithm and Data Structure（Intro），Introduction to Theoretical Computer Science, Elementary ofMachine Learning 这几门课。 感觉不赖，但考试保证通过的可能只有Prog1 和ALDS， itcs和EML都得多下点功夫了。</p><h2 id="旅行">旅行</h2><p>今年去的地方不少，主要是刚上大学，家里气氛宽松了不少，天南海北都走了走。</p><h3 id="二月沪的后花园和沪">二月——沪的后花园和沪</h3><p>为了给弟弟的承诺，出发！</p><h4 id="第一站tokyo">第一站，Tokyo</h4><p>本次旅行，选择了从东玩到西。</p><p>刚到那，就碰上了人身事故，属实日本特色了。 <img src="/posts/1f18a9aa/Accident.jpg" class="" title="人身事故"></p><p>第一天刚到，先去了UenoZoo和葛饰北斋博物馆，然后拐去旧安田庭院看了一眼，打卡本所怪谈取景处。然后跑秋叶原看了一眼，进了煤炉，只能说我还不是纯种二次元吧，实在没啥拿三十好几买小铁片的意愿。不过这可能是好事吧。倒是弟弟买了个蓝锁的Badge，不赖。最后晚上登上SkyTree，远远看了看东京塔和东京夜景。只能说不愧是东京，真的繁华，之后的上海都没那种感觉。<img src="/posts/1f18a9aa/TokyoTower.jpg" class="" title="天空树"></p><p>第二天，去了东京国立博物馆，整体没记住什么，只记得有一堆汉字，能慢慢品读（。同时还在正对大门的楼梯浅浅拍照打了个卡，P5巡礼照片，get！还有这个铸币小人XD。 <img src="/posts/1f18a9aa/P5.jpg" class="" title="Persona!!!"> 之后去了神田教堂，也是P5巡礼点。<img src="/posts/1f18a9aa/Church.jpg" class="" title="一二三，我的一二三，嘿嘿……">然后就去了新宿。只能说人确实多，充斥着白人想来整泡泡浴的。不过我们一家的目的倒是去吃寿喜锅和牛肉了。这甜口刚吃起来挺不错，新鲜好吃。可惜后面越来越齁，店员还一直不给加水，差评！不过确实好吃，下次可能还回来，记得预约，<ahref="https://maps.app.goo.gl/c5zuDCS1SvjqrBcRA">谷歌地图地址</a>。晚上打卡Sunshine City，可惜没找到处华脑内小剧场的地方。去看了个观星就回去休息了。</p><p>第三天一早，坐上新干线，向环球影城出发！！！</p><h3 id="第二站ōsaka">第二站，Ōsaka</h3><blockquote><p>遭报应了，现在打dota奇卡无比，滚回来写总结了更新，散热模组报废了，再说吧QwQ</p></blockquote><p>这里是这次来日本的主题，环球影城！ 住处选在了一处<ahref="https://zh.airbnb.com/rooms/1170815027172354778?source_impression_id=p3_1767365286_P3rAXhBEGzehJvrq">一户建</a>，也是体验上了住小别墅的感觉。整体空间还是比较宽敞的，也够一家子住。不过浴室放一楼确实有点不方便了。</p><p>然后便是去了朝思夜想的USJ。第一天去那里主要是在哈利波特和马里奥园区在玩。先拿Amiya银联卡整了个魔杖付费DLC，玩了玩互动项目（喷火和火车蒸汽是真帅啊）,喝了喝黄油啤酒，真好喝，糖油混合物是这样的。</p><p>然后是Cup Cake转圈圈和幼儿乐园。不赖，但没那么惊艳。</p><p>进入马里奥园区，购买手环DLC。因为进去的时间是下午，整理券只有晚上八点的了。先玩了点小游戏，然后捡漏进入马车街机版，头戴AR眼睛，有趣。</p><p>（先写到这里，明天再更）</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20241123</title>
    <link href="/posts/2824b3df.html"/>
    <url>/posts/2824b3df.html</url>
    
    <content type="html"><![CDATA[<h2 id="happy-birthday">Happy birthday!</h2><p>吃烤腰子前一定要看好是内腰还是外腰 QwQ</p>]]></content>
    
    
    
    <tags>
      
      <tag>生日快乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>note-cs61c</title>
    <link href="/posts/70c0549d.html"/>
    <url>/posts/70c0549d.html</url>
    
    <content type="html"><![CDATA[<h2 id="section">24.11.1</h2><p><code>auipc</code> 加载高20位</p>]]></content>
    
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20241027</title>
    <link href="/posts/2e8b1df1.html"/>
    <url>/posts/2e8b1df1.html</url>
    
    <content type="html"><![CDATA[<h2 id="weblab-w89">WebLab w8,9</h2><p>学到了一些前端框架的开发习惯：</p><ol type="1"><li>container套container来实现排版效果</li><li>与数据库交互时，检查登录状态（isLoggedin）。</li><li>与Mongodb交互时的查找方法：新建一个json，里面写上键值，然后<code>.find(...).then(...)</code></li></ol><h3 id="一些感受">一些感受</h3><p>ETH有点小寄。忙来忙去，现在看来，还是先找工，手里拿着钱，身上有些可以被剥削的价值，再去整这些润的事吧。</p><p>累了，也不太想花父母钱了………</p><p>ALL in 找工！</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20241019</title>
    <link href="/posts/e21e6335.html"/>
    <url>/posts/e21e6335.html</url>
    
    <content type="html"><![CDATA[<h2 id="校赛总结">校赛总结</h2><h3 id="成绩">成绩</h3><p>银牌，做出了 A，B，D，G，J</p><h3 id="a-boosting">A Boosting</h3><p>签到题。</p><h3 id="b-burning">B Burning</h3><p>题意描述：你有许多绳子， <strong>1.不均匀 2.随时可以熄灭</strong>，能烧1h。 给定时间（hh:mm:ss），请问是否可以烧出。</p><p>题解：取两根绳子，A烧一头，B烧两头，当B烧完时熄灭A，可得到一根可以烧出15min的绳子C（两头烧）。最短时间为225s。据此判断即可。</p><h3 id="c-calendar">C Calendar</h3><p>大模拟，感觉没啥能说的</p><h3 id="d-card">D Card</h3><p>水题，直接算即可</p><h3 id="e-chatgpt">E Chatgpt</h3><p>题意描述：给定三个操作：</p><ul><li>注：所有的“显示字符串”意思均为显示 <spanclass="math inline"><em>Σ</em><sub><em>y</em> = 1</sub><sup>|<em>S</em>|</sup><em>S</em><sub><em>i</em></sub><em>B</em><sup><em>i</em></sup><em>m</em><em>o</em><em>d</em>2<sup>64</sup>, <em>B</em> = 131</span>哈希后的字符串异或和</li></ul><ol type="1"><li>添加一段新问答：1 Q A，显示Q与A</li><li>选择一个回答，添加一段问答：2. Q’ A’,显示所有已知问答</li><li>选择一个提问（Q），修改，给出新的回答，附在Q的上一条问答后</li></ol><p>可持久化数据结构的考察，可以用链表，没有写。</p><h3 id="f-discrete">F Discrete</h3><p>题意：给定<span class="math inline"><em>m</em></span>，求<spanclass="math inline">1 (<em>m</em> − 1)<sup>2</sup></span> 中有多少个数<span class="math inline"><em>n</em></span>满足<spanclass="math inline"><em>n</em> ≡ <em>b</em>( mod  <em>m</em>)</span></p><p>不会QwQ</p><h3 id="g-dns">G DNS</h3><p>水题，<code>map+vector</code> 随便写</p><h3 id="h-configure-network">H Configure Network</h3><p>题意： 给定<spanclass="math inline"><em>n</em> * <em>n</em></span>矩阵,求从第一列到第最后一列，点权和恰好为<spanclass="math inline"><em>t</em></span>的路径</p><p>解法：双边搜索+bitset建桶。</p><p>好久不做题，想到了没敢写。该打。</p><h3 id="i-teleport">I Teleport</h3><p>题意：给定n个坐标，要有n次<spanclass="math inline">(0, 0)− &gt; (<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>)− &gt; (0, 0)</span>，但拥有传送门，1s送到距所在位置切比雪夫距离在<spanclass="math inline">[<em>l</em>, <em>r</em>]</span> 的点，<spanclass="math inline"><em>r</em> ≤ <em>k</em></span>。最小化 <spanclass="math inline"><em>r</em> − <em>l</em> + 1</span></p><p>没有做，考场上没有看。</p><h3 id="j-three-body">J Three Body</h3><p>题意：求三个圆都覆盖到的面积</p><p>解法：计算几何板子</p><h3 id="k-tree">K Tree</h3><p>题意：给定n组数据：fa l。fa为父亲的下标，l为长度。在第<spanclass="math inline"><em>i</em></span>行第<spanclass="math inline"><em>m</em></span>层（父节点及祖宗节点个数）长度为<spanclass="math inline"><em>l</em></span>的节点花费为<spanclass="math inline"><em>i</em> * (<em>m</em> + <em>l</em>)</span></p><p>做法：大概就是存长度和层数排序</p><h3 id="l-tube">L Tube</h3><p>没看懂</p><h3 id="m-no-left-turn">M No Left Turn</h3><p>一道神奇的图论，没看懂</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20241017</title>
    <link href="/posts/44381.html"/>
    <url>/posts/44381.html</url>
    
    <content type="html"><![CDATA[<h2 id="deutsch">Deutsch</h2><p>学习了第四格的人称代词：</p><table><thead><tr><th style="text-align: center;">第一格</th><th style="text-align: center;">物主代词</th><th style="text-align: center;">第四格</th></tr></thead><tbody><tr><td style="text-align: center;">ich</td><td style="text-align: center;">mein</td><td style="text-align: center;">mich</td></tr><tr><td style="text-align: center;">du</td><td style="text-align: center;">dein</td><td style="text-align: center;">dich</td></tr><tr><td style="text-align: center;">er</td><td style="text-align: center;">sein</td><td style="text-align: center;">ihn</td></tr><tr><td style="text-align: center;">sie</td><td style="text-align: center;">ihr</td><td style="text-align: center;">sie</td></tr><tr><td style="text-align: center;">es</td><td style="text-align: center;">sein</td><td style="text-align: center;">es</td></tr><tr><td style="text-align: center;">wir</td><td style="text-align: center;">unser</td><td style="text-align: center;">uns</td></tr><tr><td style="text-align: center;">ihr</td><td style="text-align: center;">euer</td><td style="text-align: center;">euch</td></tr><tr><td style="text-align: center;">sie</td><td style="text-align: center;">sein</td><td style="text-align: center;">sie</td></tr><tr><td style="text-align: center;">Sie</td><td style="text-align: center;">Ihr</td><td style="text-align: center;">Sie</td></tr><tr><td style="text-align: center;">wer</td><td style="text-align: center;">wessen</td><td style="text-align: center;">wen</td></tr></tbody></table><h2 id="programming">Programming</h2><p>详见 <ahref="./39095.html#关于字符串读取的问题">关于字符串读取的问题</a></p><h2 id="feeling">Feeling</h2><p>最近头又有点晕，不会高血压了吧😢。</p><p>要打印<ahref="ACM-ICPC_Templates_201805.pdf">ACM的板子</a>了，200多页，好贵</p><p>更：好像才40多，还能接受。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Journal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题小点</title>
    <link href="/posts/39095.html"/>
    <url>/posts/39095.html</url>
    
    <content type="html"><![CDATA[<h2 id="关于字符串读取的问题">关于字符串读取的问题</h2><p>getline(std::cin,str) 读取到缓冲区<code>'\n'</code> 前的字符串。故在<code>std::cin&gt;&gt;n&gt;&gt;m</code>这样的代码后，第一次读到的会是空串。因此需要有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(str==<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-built_in">getline</span>(std::cin,str);<br></code></pre></td></tr></table></figure><p>这样的代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>note-weblab-w0</title>
    <link href="/posts/16111.html"/>
    <url>/posts/16111.html</url>
    
    <content type="html"><![CDATA[<h2 id="总结">总结</h2><ol type="1"><li><p><code>flex</code> 中，默认使用行排布</p></li><li><p><code>flex-grow</code> 控制单元大小</p></li><li><p>清除计时器需要给<code>setInterval</code>一个名字（<code>let sth = setInterval(func,time)</code>）</p></li></ol><h3 id="section">10.10</h3><p>扩展不定数量多个元素时，可以使用 map() 进行。</p><ul><li><strong>Parentheses <code>()</code></strong>: Used for arrowfunctions. <strong>Implicit return</strong> statement if there’s onlyone expression.</li><li><strong>Curly Braces <code>&#123;&#125;</code></strong>: Used for regularfunction declarations. Explicit <code>return</code> statementneeded.</li></ul><h3 id="section-1">10.27</h3><p>学到了一些前端框架的开发习惯：</p><ol type="1"><li>container套container来实现排版效果</li><li>与数据库交互时，检查登录状态（isLoggedin）。</li><li>与Mongodb交互时的查找方法：新建一个json，里面写上键值，然后<code>.find(...).then(...)</code></li></ol><h3 id="section-2">10.28</h3><p>GET/POST 解决客户端与服务器通讯 Socket解决服务器与客户端通信</p><h3 id="section-3">10.30</h3><p>useEffect中return的函数在这个结构销毁时调用，等价于构析函数。</p><p>检查是否有函数并调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">func &amp;&amp; <span class="hljs-title function_">func</span>(para)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20240926</title>
    <link href="/posts/25421.html"/>
    <url>/posts/25421.html</url>
    
    <content type="html"><![CDATA[<h2 id="总结">总结</h2><p>今天到19:47只写了三道题，小问题属于是一点敏感度都没有。</p><p>先是一道贪心因为神奇的原因没做出来。</p><p>然后是优先队列可能多次取都没注意到。</p><p>服了。</p><p>但是上午还是把多项式理论往后推进了一些，该整整数学分析了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20240923</title>
    <link href="/posts/24717.html"/>
    <url>/posts/24717.html</url>
    
    <content type="html"><![CDATA[<h1 id="小总结">小总结</h1><p>开局首绷：答案字符串不写换行，属于是一点竞赛记忆都不剩了。</p><p>不过正好，从头学起，把之前拉下的全补牢。</p><p>然后学习一下牛顿迭代，挺好写，爱写。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><span class="hljs-comment">//some function</span></span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">df</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> <span class="hljs-comment">//the derivative of the function</span></span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">newtonIterate</span><span class="hljs-params">(<span class="hljs-type">double</span> eps=<span class="hljs-number">1e-7</span>,<span class="hljs-type">int</span> maxIt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> curr = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=maxIt;++i)<br>    &#123;<br>        <span class="hljs-type">double</span> fx = <span class="hljs-built_in">f</span>(curr);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(fx)&lt;eps)<br>            <span class="hljs-keyword">return</span> curr;<br>        <span class="hljs-type">double</span> dfx=<span class="hljs-built_in">df</span>(curr)<br>        <span class="hljs-keyword">if</span>(dfx==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        curr-=fx/dfx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>基本思想：</li><li>不断做切线，其与x轴相交的点x1一定比原来的点x0离零点更近，故可以不断逼近，得到所需精度的答案。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmp</title>
    <link href="/posts/28269.html"/>
    <url>/posts/28269.html</url>
    
    <content type="html"><![CDATA[<h1 id="搞不懂">搞不懂</h1><p>啦啦啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>20240922</title>
    <link href="/posts/41036.html"/>
    <url>/posts/41036.html</url>
    
    <content type="html"><![CDATA[<h1 id="回归辣">回归辣</h1><h2 id="昨日总结">昨日总结</h2><p>给昨天先做一下总结</p><ol type="1"><li>骑车到达尖岭沙滩，闻到了海的味道，舒服。</li><li>重建了博客，今后要多写多总结</li><li>复建CF，但是发现自己好菜啊。 另： 不开<code>long long</code>见祖宗</li><li>早上看了看丘维声的高等代数。这才是好的大学老师的模样啊！</li></ol><p>大概就是这些了，今日事件晚上再更新。</p><p>下面是一些图片：</p><img src="/posts/41036/cows.jpg" class="" title="牛"><img src="/posts/41036/sea.jpg" class="" title="海"><img src="/posts/41036/chair.jpg" class="" title="椅"><img src="/posts/41036/sea.jpg" class="" title="花">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
