<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构基础知识速览</title>
    <link href="/2023/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/"/>
    <url>/2023/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>来打板子练练手（雾</p><h3 id="树状数组-BIT"><a href="#树状数组-BIT" class="headerlink" title="树状数组-BIT"></a>树状数组-BIT</h3><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<span class="hljs-comment">//数据个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> data[maxn];<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> ((-x) &amp; (x));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (; x &lt;= n; x += <span class="hljs-built_in">lowbit</span>(x))<br>            data[x] += y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; x; x -= lowbit)<br>            ans += data[x];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span><br>&#123;<br>    <span class="hljs-type">int</span> c1[maxn], c2[maxn];<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> tmp = x * y;<br>        <span class="hljs-keyword">for</span>(; x; x += <span class="hljs-built_in">lowbit</span>(x))<br>            c1[x] += y, c2[x] += tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">add</span>(l, val), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> id = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(id==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span>(;x ;x -= <span class="hljs-built_in">lowbit</span>(x))<br>                ans += c1[x];<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">for</span>(;x ;x -= <span class="hljs-built_in">lowbit</span>(x))<br>                ans += c2[x];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (r + <span class="hljs-number">1ll</span>) * <span class="hljs-built_in">qeury</span>(r, <span class="hljs-number">1</span>) - <span class="hljs-number">1ll</span> * l * <span class="hljs-built_in">qeury</span>(l - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) -<br>         (<span class="hljs-built_in">qeury</span>(r, <span class="hljs-number">2</span>) - <span class="hljs-built_in">qeury</span>(l - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="线段树-SegmentTree"><a href="#线段树-SegmentTree" class="headerlink" title="线段树-SegmentTree"></a>线段树-SegmentTree</h3><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-keyword">namespace</span> SegTree<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>;<br><span class="hljs-keyword">typedef</span> Node* lpNode;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    lpNode ls, rs;<br>    ll val = <span class="hljs-number">0</span>, mark = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        val = ls-&gt;val + rs-&gt;val;<br>    &#125;<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e6</span>;<br>Node pool[maxn];<br>lpNode root = pool;<br>lpNode cnt  = pool + <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(lpNode p, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (p-&gt;ls == <span class="hljs-literal">nullptr</span>) p-&gt;ls = ++cnt;<br>    <span class="hljs-keyword">if</span> (p-&gt;rs == <span class="hljs-literal">nullptr</span>) p-&gt;rs = ++cnt;<br>    <span class="hljs-keyword">if</span> (!p-&gt;mark) <span class="hljs-keyword">return</span>;<br>    p-&gt;ls-&gt;val += p-&gt;mark * (len / <span class="hljs-number">2</span>);<br>    p-&gt;ls-&gt;mark += p-&gt;mark;<br>    p-&gt;rs-&gt;val += p-&gt;mark * (len - len / <span class="hljs-number">2</span>);<br>    p-&gt;rs-&gt;mark += p-&gt;mark;<br>    p-&gt;mark = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, lpNode p = root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> p-&gt;val = a[l], <span class="hljs-built_in">void</span>();<br>    <span class="hljs-type">int</span> mid = (l + r - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pushDown</span>(p, r - l + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">build</span>(l, mid, p-&gt;ls);<br>    <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, p-&gt;rs);<br>    p-&gt;<span class="hljs-built_in">upd</span>();<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, lpNode p = root, <span class="hljs-type">int</span> cl = L, <span class="hljs-type">int</span> cr = R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="hljs-keyword">return</span> p-&gt;val;<br>    <span class="hljs-built_in">pushDown</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    ll mid = (cl + cr - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) ans += <span class="hljs-built_in">query</span>(l, r, p-&gt;ls, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) ans += <span class="hljs-built_in">query</span>(l, r, p-&gt;rs, mid + <span class="hljs-number">1</span>, cr);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d, lpNode p = root, <span class="hljs-type">int</span> cl = L, <span class="hljs-type">int</span> cr = R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>        <span class="hljs-keyword">return</span> p-&gt;mark += d, p-&gt;val += d * (cr - cl + <span class="hljs-number">1</span>), <span class="hljs-built_in">void</span>();<br>    <span class="hljs-built_in">pushDown</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> mid = (cl + cr - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) <span class="hljs-built_in">modify</span>(l, r, d, p-&gt;ls, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) <span class="hljs-built_in">modify</span>(l, r, d, p-&gt;rs, mid + <span class="hljs-number">1</span>, cr);<br>    p-&gt;<span class="hljs-built_in">upd</span>();<br>&#125;<br>&#125; <span class="hljs-comment">// namespace SegTree</span><br></code></pre></div></td></tr></table></figure><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><p>算法过程: 两次<code>dfs</code>, 第一次找重儿子(重链剖分), 第二次处理dfs序与子树最大dfs序，最后利用线段树维护</p><h4 id="第一次dfs"><a href="#第一次dfs" class="headerlink" title="第一次dfs"></a>第一次dfs</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> hson[maxn], fa[maxn], siz[maxn], dep[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size  = <span class="hljs-number">1</span>, ma = <span class="hljs-number">0</span>;<br>    dep[p] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span>(!dep[e-&gt;to])<br>        &#123;<br>            <span class="hljs-built_in">dfs1</span>(e-&gt;to, d + <span class="hljs-number">1</span>);<br>            fa[e-&gt;to] = p;<br>            size += size[e-&gt;to];<br>            <span class="hljs-keyword">if</span>(siz[e-&gt;to] &gt; ma)<br>                hson[p] = e-&gt;to, ma = siz[e-&gt;to];<br>        &#125;<br>    siz[p] = size;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="第二次dfs"><a href="#第二次dfs" class="headerlink" title="第二次dfs"></a>第二次dfs</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> madfn[maxn], dfn[maxn], top[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    madfn[p] = dfn[p] = ++tim;<br>    <span class="hljs-keyword">if</span> (hson[p] != <span class="hljs-number">0</span>)<br>    &#123;<br>        top[hson[p]] = top[p];<br>        <span class="hljs-built_in">dfs2</span>(hson[p]);<br>        madfn[p] = std::<span class="hljs-built_in">max</span>(madfn[p], madfn[hson[p]]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span>(!top[e-&gt;to])<br>        &#123;<br>            top[e-&gt;to] = e-&gt;to;<br>            <span class="hljs-built_in">dfs2</span>(e-&gt;to);<br>            madfn[e-&gt;to] = std::<span class="hljs-built_in">max</span>(madfn[e-&gt;to], madfn[p]);<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="求LCA"><a href="#求LCA" class="headerlink" title="求LCA"></a>求LCA</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (top[a] != top[b])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[a]] &gt; dep[top[b]])<br>            a = fa[top[a]];<br>        <span class="hljs-keyword">else</span><br>            b = fa[top[b]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> (dep[a] &gt; dep[b] ? b : a);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="修改链上权值"><a href="#修改链上权值" class="headerlink" title="修改链上权值"></a>修改链上权值</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &gt; dep[top[y]])<br>        &#123;<br>            <span class="hljs-built_in">modify</span>(dfn[top[x]], dfn[x], val);<br>            x = fa[top[x]];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">modify</span>(dfn[top[y]], dfn[y], val);<br>            y = fa[top[y]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])<br>        <span class="hljs-built_in">modify</span>(dfn[y], dfn[x], val);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">modify</span>(dfn[x], dfn[y], val);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="两点间点权和"><a href="#两点间点权和" class="headerlink" title="两点间点权和"></a>两点间点权和</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(top[x]!=top[y])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dep[top[x]]&gt;dep[top[y]])<br>        &#123;<br>            ans+=<span class="hljs-built_in">query</span>(dfn[top[x]],dfn[x]);<br>            x = fa[top[x]];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            ans+=<span class="hljs-built_in">query</span>(dfn[top[y]],dfn[y]);<br>            y = fa[top[y]];<br>        &#125;<br>    &#125;<br>     <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])<br>        ans += <span class="hljs-built_in">query</span>(dfn[y], dfn[x]);<br>    <span class="hljs-keyword">else</span><br>        ans += <span class="hljs-built_in">query</span>(dfn[x], dfn[y]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="子树修改-amp-查询"><a href="#子树修改-amp-查询" class="headerlink" title="子树修改&amp;查询"></a>子树修改&amp;查询</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifySubtree</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">modifyPath</span>(dfn[x],madfn[x],val);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querySubtree</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queryPath</span>(dfn[x],madfn[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="线段树的建立"><a href="#线段树的建立" class="headerlink" title="线段树的建立"></a>线段树的建立</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> A[maxn],B[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>    std::cin&gt;&gt;B[i];<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>    A[dfn[i]] = B[i];<br><span class="hljs-built_in">build</span>();<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树笔记之一</title>
    <link href="/2023/04/15/%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/"/>
    <url>/2023/04/15/%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ_Treap"></a>FHQ_Treap</h1><p><del>毕竟连pb_ds用的splay都是一个叫$p14y 7r33 7481的奇怪数据结构你说是吧</del></p><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>我们都知道，普通二叉搜索树会被卡掉的原因是数据可能会单调给出，这时树就会退化成一条链<br>那么我们如果人为的将数据的顺序打乱，那么这棵树就会“更平衡”。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>由它的名字便可知，这是一个tree + heap的数据结构<br>具体来说，在插入与创建新节点时，额外赋给每个节点一个随机权值，使得原始权值满足二叉搜索树的性质，随机权值满足堆的性质<br>为什么这样一定对呢？<br>因为权值是随机的，因此堆的形态是不确定的，进而达到了类似“打乱后插入”的效果</p><p>普通Treap使用的是传统的树旋转，但FHQ实现的时候，使用了类似 “拼图” 的思想, 核心函数只有两个：分裂（split）、合并（merge）。<br>分裂又分为按值分裂与按大小分裂<br>下面在代码中会讲解。</p><p>它相较于普通Treap，虽然常数略大，但码量小，好写。</p><h2 id="关键代码实现"><a href="#关键代码实现" class="headerlink" title="关键代码实现"></a>关键代码实现</h2><h3 id="根节点的定义"><a href="#根节点的定义" class="headerlink" title="根节点的定义"></a>根节点的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(p) tr[p].ls</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(p) tr[p].rs</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> val(p) tr[p].val</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> siz(p) tr[p]siz</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ind(p) tr[p]ind</span><br><span class="hljs-type">int</span> cnt, root;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> ls, rs;<br>    <span class="hljs-type">int</span> val, ind, siz; <span class="hljs-comment">//ind为随机id</span><br>&#125; tr[maxn];<br></code></pre></div></td></tr></table></figure><h3 id="分裂操作"><a href="#分裂操作" class="headerlink" title="分裂操作"></a>分裂操作</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//now为现在节点的编号，val为按值分裂时的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!now)x = y = <span class="hljs-number">0</span>; <span class="hljs-comment">//分裂到了空节点，返回</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">val</span>(now) &lt;= val) <span class="hljs-comment">//向右分裂</span><br>        &#123;<br>            x = now;<br>            <span class="hljs-built_in">split</span>(<span class="hljs-built_in">rs</span>(now), val, <span class="hljs-built_in">rs</span>(now), y);<br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//向左分裂</span><br>        &#123;<br>            y = now;<br>            <span class="hljs-built_in">split</span>(<span class="hljs-built_in">ls</span>(now), val, x, <span class="hljs-built_in">ls</span>(now));<br>        &#125;<br>        <span class="hljs-built_in">update</span>(now);<span class="hljs-comment">//更新子树大小</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后分裂出的两棵树 <code>x, y</code> ，一棵满足 “树中的数都小于val”, 一颗满足 “大于等于”。</p><h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!x || !y)<span class="hljs-keyword">return</span> x + y; <span class="hljs-comment">//若有空节点，就直接返回另一个。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ind</span>(x) &gt; <span class="hljs-built_in">ind</span>(y)) <span class="hljs-comment">//传参时已经保证 val(x)&lt;val(y)</span><br>    &#123;<br>        <span class="hljs-built_in">rs</span>(x) = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">rs</span>(x), y);<br>        <span class="hljs-built_in">update</span>(x);<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">ls</span>(y) = <span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">ls</span>(y));<br>        <span class="hljs-built_in">update</span>(y);<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>返回值为合并后的根节点。</p><p>有了这两种操作，一切操作就都水到渠成了。</p><h2 id="总体实现"><a href="#总体实现" class="headerlink" title="总体实现"></a>总体实现</h2><p><a href="https://github.com/StableAgOH/Codebase/blob/master/Code/%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%B3%BB%E5%88%97/fhq%20Treap/fhq%20Treap(%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91">感谢AGOH大佬的代码</a>.cpp)</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-function">std::mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-number">233</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">val</span>(++cnt) = val;<br>    <span class="hljs-built_in">siz</span>(cnt) = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">ind</span>(cnt) = <span class="hljs-built_in">rnd</span>();<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">//新建节点，返回值为新节点编号</span><br><span class="hljs-type">int</span> x, y, z;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br>&#123;<br>    <span class="hljs-built_in">split</span>(root, val, x, y); <span class="hljs-comment">//先按值val分裂成两棵树，一棵小于等于 val,一棵大于val</span><br>    root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">newNode</span>(val)), y); <span class="hljs-comment">//因此，只需将x树，新节点，与y树依次合并即可</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val, x, z); <span class="hljs-comment">//x全都小于等于val，z都大于val</span><br>    <span class="hljs-built_in">split</span>(x, val - <span class="hljs-number">1</span>, x, y); <span class="hljs-comment">//x全部小于val，y全部等于val</span><br>    y = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">ls</span>(y), <span class="hljs-built_in">rs</span>(y)); <span class="hljs-comment">//减掉一个val的节点</span><br>    root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, y), z); <span class="hljs-comment">//拼回去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getRank</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val - <span class="hljs-number">1</span>, x, y); <span class="hljs-comment">//x树上的值都比val小</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">siz</span>(x) + <span class="hljs-number">1</span>; <span class="hljs-comment">//排名就是x的大小+1</span><br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-type">int</span> rank)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> now = root;<br>    <span class="hljs-keyword">while</span> (now)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">siz</span>(<span class="hljs-built_in">ls</span>(now)) + <span class="hljs-number">1</span> == rank)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">siz</span>(<span class="hljs-built_in">ls</span>(now)) &gt;= rank)<br>            now = <span class="hljs-built_in">ls</span>(now);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            rank -= <span class="hljs-built_in">siz</span>(<span class="hljs-built_in">ls</span>(now)) + <span class="hljs-number">1</span>; <span class="hljs-comment">//类似主席树的查找</span><br>            now = <span class="hljs-built_in">rs</span>(now);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">val</span>(now);<br>&#125;<br><br><span class="hljs-comment">//前驱:第一个小于val小的</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val - <span class="hljs-number">1</span>, x, y);<br>    <span class="hljs-type">int</span> now = x;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rs</span>(now))<br>        now = <span class="hljs-built_in">rs</span>(now);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">val</span>(now);<br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//后继:第一个比val大的</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">nxt</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val, x, y);<br>    <span class="hljs-type">int</span> now = y;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">ls</span>(now))<br>        now = <span class="hljs-built_in">ls</span>(now);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">val</span>(now);<br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>upd: 2021.11.18 </p><p>使用指针重新实现。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;random&gt;</span></span><br><br><span class="hljs-function">std::mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-number">19260817</span>)</span></span>;<br><br><span class="hljs-keyword">namespace</span> FHQ_Treap<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    Node *ls, *rs;<br>    <span class="hljs-type">int</span> ind = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>, siz = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> val, Node *tmp)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;val = val;<br>        <span class="hljs-keyword">this</span>-&gt;siz = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>-&gt;ind = <span class="hljs-built_in">rnd</span>();<br>        <span class="hljs-keyword">this</span>-&gt;ls = <span class="hljs-keyword">this</span>-&gt;rs = tmp;<br>    &#125;<br>    <span class="hljs-built_in">Node</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br>Node *nil = <span class="hljs-keyword">new</span> Node;<br>Node *root = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(Node *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p-&gt;siz = p-&gt;ls-&gt;siz + p-&gt;rs-&gt;siz + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(Node *p, <span class="hljs-type">int</span> val, Node *&amp;x, Node *&amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == nil)<br>        x = y = nil;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;val &lt;= val)<br>        &#123;<br>            x = p;<br>            <span class="hljs-built_in">split</span>(p-&gt;rs, val, p-&gt;rs, y);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            y = p;<br>            <span class="hljs-built_in">split</span>(p-&gt;ls, val, x, p-&gt;ls);<br>        &#125;<br>        <span class="hljs-built_in">upd</span>(p);<br>    &#125;<br>&#125;<br><span class="hljs-function">Node *<span class="hljs-title">merge</span><span class="hljs-params">(Node *x, Node *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == nil)<br>        <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span> (y == nil)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">if</span> (x-&gt;ind &lt; y-&gt;ind)<br>    &#123;<br>        x-&gt;rs = <span class="hljs-built_in">merge</span>(x-&gt;rs, y);<br>        <span class="hljs-built_in">upd</span>(x);<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        y-&gt;ls = <span class="hljs-built_in">merge</span>(x, y-&gt;ls);<br>        <span class="hljs-built_in">upd</span>(y);<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br>Node *x, *y, *z;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, nil), <span class="hljs-built_in">void</span>();<br>    <span class="hljs-built_in">split</span>(root, val, x, y);<br>    root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, nil)), y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val, x, z);<br>    <span class="hljs-built_in">split</span>(x, val - <span class="hljs-number">1</span>, x, y);<br>    y = <span class="hljs-built_in">merge</span>(y-&gt;ls, y-&gt;rs);<br>    root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, y), z);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRank</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val - <span class="hljs-number">1</span>, x, y);<br>    <span class="hljs-keyword">auto</span> tmp = x-&gt;siz + <span class="hljs-number">1</span>;<br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getVal</span><span class="hljs-params">(<span class="hljs-type">int</span> rnk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> p = root;<br>    <span class="hljs-keyword">while</span> (p != nil)<br>    &#123;<br>        <span class="hljs-comment">// upd(p);</span><br>        <span class="hljs-keyword">if</span> (p-&gt;ls-&gt;siz + <span class="hljs-number">1</span> == rnk)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;ls-&gt;siz &gt;= rnk)<br>            p = p-&gt;ls;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            rnk -= p-&gt;ls-&gt;siz + <span class="hljs-number">1</span>;<br>            p = p-&gt;rs;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p-&gt;val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPre</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val - <span class="hljs-number">1</span>, x, y);<br>    <span class="hljs-keyword">auto</span> p = x;<br>    <span class="hljs-keyword">while</span> (p-&gt;rs != nil)<br>        p = p-&gt;rs;<br>    <span class="hljs-type">int</span> ans = p-&gt;val;<br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNxt</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(root, val, x, y);<br>    <span class="hljs-keyword">auto</span> p = y;<br>    <span class="hljs-keyword">while</span> (p-&gt;ls != nil)<br>        p = p-&gt;ls;<br>    <span class="hljs-type">int</span> ans = p-&gt;val;<br>    root = <span class="hljs-built_in">merge</span>(x, y);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BSGS</title>
    <link href="/2023/04/15/BSGS/"/>
    <url>/2023/04/15/BSGS/</url>
    
    <content type="html"><![CDATA[<h1 id="BSGS-amp-exBSGS"><a href="#BSGS-amp-exBSGS" class="headerlink" title="BSGS &amp; exBSGS"></a>BSGS &amp; exBSGS</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在解决了一般的模意义下的低次同余方程后，高次同余方程又该如何解决呢？<br>在这里的 “高次同余方程” 指两种，一种是 $a ^x\equiv b \pmod p$, 另一种是 $x ^a\equiv b\pmod p$<br>而今天的 <strong>BSGS </strong> ，解决的就是第一种方程。</p><h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>普通的BSGS，在使用时的前提条件是 $a, p$ 互质。<br>因为在模意义下， $a ^x$ 必有一个长度为 $\varphi(p)$ 的循环节。<br>所以朴素算法的思想就出来了： 枚举至多 $\varphi(p)$ 次，时间复杂度最劣为 $\mathcal<br>{<br>    \Theta(\varphi(p))<br>}$ 。<br>这显然是不够的。<br>所以我们可以对这种方法使用类似折半搜索的思想进行化简。</p><p>考虑将原式化作 <script type="math/tex">a ^ {At - B}\equiv b\pmod p, (B\in[1, t))</script> 的形式。<br>   进一步地，我们可将其化作 $a ^ {At}\equiv ba ^ {B}\pmod p$ 的形式。<br>   我们发现，在这种情况下，我们的枚举的复杂度就降到了 $\mathcal{O(t\bmod p + \frac{\varphi(p)}{t})}$ 。<br>不难发现， $t$ 最理想的的大小是 $\lceil\sqrt{\varphi(p)} \rceil$ 。为了避免求欧拉函数，我们可以选择直接取 $\sqrt{p}$ 作为 $t$ 的值，可以发现， $t$ 的值一定是大于 $\varphi(p)$ 的，因此一定可以包含所有的情况。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>首先，将右边所有可能的取值扔进哈希表 $\mathcal{O(\sqrt{p})}$<br>其次，从小到大计算左边的所有的可能取值 $\mathcal{O(\sqrt{p})}$<br>这样，我们便能在 $\mathcal{O(\sqrt{p})}$ 的时间内解出这两个高次方程的解了。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">BSGS</span><span class="hljs-params">(ll a, ll b, ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// cur是左边的 a^b，可复用,因为p为质数，因此t为……</span><br>    ll cur = <span class="hljs-number">1</span>, t = <span class="hljs-built_in">sqrt</span>(p) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//pbds哈希表，map会有log，unordered_map种子是被焊死的，会被卡</span><br>    __gnu_pbds::gp_hash_table&lt;ll, ll&gt; tb;<br>    tb.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> B = <span class="hljs-number">1</span>; B &lt;= t; ++B)<br>    &#123;<br>        (cur *= a) %= p;<br>        tb[b * cur % p] = B;<br>    &#125;<br>    ll now = cur;<span class="hljs-comment">//现在的cur就是 a^t</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> A = <span class="hljs-number">1</span>; A &lt;= t; ++A)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = tb.<span class="hljs-built_in">find</span>(now);<br>        <span class="hljs-keyword">if</span> (it != now)<br>            <span class="hljs-keyword">return</span> A * t - it-&gt;second; <span class="hljs-comment">//A*t-B</span><br>        (now *= cur) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -INF;<span class="hljs-comment">//无解</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>上面的代码处理的是 $a, p$ 互质的情况。那么不互质时会怎样呢？</p><p>我们可以考虑将其转化成互质的情况</p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p>原式可化为 <script type="math/tex">a ^ {x - 1} a + np = b</script><br>根据 <strong>裴蜀定理 </strong> 可得，该方程有解，当且仅当 $b | gcd(a, p)$ 。<br>若有解，该方程可进一步化为 <script type="math/tex">\frac{a ^{x - 1} a} {d} +\frac{np} {d} = \frac{b} {d}</script><br>即 <script type="math/tex">\frac{a} {d} a ^ {x - 1}\equiv \frac{b} {d}\pmod {\frac{p}{d}}</script><br>此时，若 $a, \frac{p} {d}$ 互质，则可使用一般的带系数的BSGS进行求解，否则递归进行此过程。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">BSGS</span><span class="hljs-params">(ll a, ll b, ll p, ll k = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll cur = <span class="hljs-number">1</span>, t = <span class="hljs-built_in">sqrt</span>(p) + <span class="hljs-number">1</span>;<br>    __gnu_pbds::gp_hash_table&lt;ll, ll&gt; tb;<br>    tb.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> B = <span class="hljs-number">1</span>; B &lt;= t; ++B)<br>    &#123;<br>        (cur *= a) %= p;<br>        tb[b * cur % p] = B;<br>    &#125;<br>    ll now = cur * k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> A = <span class="hljs-number">1</span>; A &lt;= t; ++A)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = tb.<span class="hljs-built_in">find</span>(now);<br>        <span class="hljs-keyword">if</span> (it != now)<br>            <span class="hljs-keyword">return</span> A * t - it-&gt;second;<br>        (now *= cur) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -INF;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">exBSGS</span><span class="hljs-params">(ll a, ll b, ll p, ll k = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    A = a %= p, B = b %= p, P = p;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll cur = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cur == B)<span class="hljs-keyword">return</span> i;<br>        cur = cur * A % P;<br>        ll d = std::__gcd(a, p);<br>        <span class="hljs-keyword">if</span> (b % d)<span class="hljs-keyword">return</span> -INF;<br>        <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-built_in">BSGS</span>(a, b, p, k * a % p);<br>        k = k * a / d % p, b /= d, p /= d;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/15/hello-world/"/>
    <url>/2023/04/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>20220618训练记录</title>
    <link href="/2022/06/18/20220618%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/18/20220618%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="AGC001"><a href="#AGC001" class="headerlink" title="AGC001"></a>AGC001</h2><p><a href="https://img.atcoder.jp/agc001/editorial.pdf">Editorial</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>贪心直接水  </p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>性质题，观察到每次都要反射形成一些三角形，从一个方向看其长度和为 $N-gcd(N,X)$ ，因此可得式子 $3\times (N-gcd(N,X))$ 。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>一道图论的性质题。<br>对于直径上的一个中点来说，</p><ul><li>若直径为偶数任何一个点到它的距离都不会超过直径的一半</li><li>若直径为奇数，则对于中心周围的点的子树内的点到它的距离都不会超过 (直径-1) / 2 。</li></ul><p>因此找出直径后，直接暴力枚举中心点位置即可，数据范围 $N\leq 2000$ ，因此可以 $\mathcal{O}(n^2)$ 通过。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>一道没能及时想出的人类智慧题。</p><p>我们发现，类似的配对问题，奇数段只能在首位出现，因此可方便判无解。</p><p>接着，我们可以考虑为开头与结尾固定为奇数并各附上一个插头，然后再在中间用偶数进行构造即可，注意 $m=1$ 时要特判</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>一道大力推柿子的题。</p><p>由题意得，柿子为：</p><p>$∑\limits^n<em>{i=1} ​∑\limits^n</em>{j=1}\binom{a_i+a_j+b_i+b_j}{a_i+b_i}$</p><p>TBC……</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>TBC</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SA</title>
    <link href="/2022/05/21/SA/"/>
    <url>/2022/05/21/SA/</url>
    
    <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> SA<br>&#123;<br><span class="hljs-type">int</span> rk[maxn &lt;&lt; <span class="hljs-number">1</span>], tmp[maxn &lt;&lt; <span class="hljs-number">1</span>], sa[maxn &lt;&lt; <span class="hljs-number">1</span>], height[maxn &lt;&lt; <span class="hljs-number">1</span>], cnt[maxn], rkt[maxn];<br>ST st;<br><span class="hljs-type">int</span> len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    len = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initSA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">void</span>(sa[<span class="hljs-number">1</span>] = rk[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; ++i)<br>        ++cnt[rk[i] = s[i]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>        cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; --i)<br>        sa[cnt[rk[i]]--] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>;; w &lt;&lt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt; len - w; --i)<br>            tmp[len - i + <span class="hljs-number">1</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, p = w; i &lt;= len; ++i)<br>            <span class="hljs-keyword">if</span> (sa[i] &gt; w) tmp[++p] = sa[i] - w;<br>        std::<span class="hljs-built_in">fill</span>(cnt + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span> + m, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; ++i)<br>            ++cnt[rkt[i] = rk[tmp[i]]];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>            cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; --i)<br>            sa[cnt[rkt[i]]] = tmp[i];<br>        m       = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> rp = [&amp;](<span class="hljs-type">int</span> x) -&gt; std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<br>        &#123; <span class="hljs-keyword">return</span> &#123;rk[x], rk[x + w]&#125;; &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; ++i)<br>            tmp[sa[i]] = <span class="hljs-built_in">rp</span>(sa[i - <span class="hljs-number">1</span>]) == <span class="hljs-built_in">rp</span>(sa[i]) ? m : ++m;<br>        std::<span class="hljs-built_in">copy</span>(tmp + <span class="hljs-number">1</span>, tmp + len + <span class="hljs-number">1</span>, rk + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (len == m) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initHeight</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; i &lt;= len; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) --k;<br>        <span class="hljs-keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="hljs-number">1</span>] + k])<br>            ++k;<br>        height[rk[i]] = k;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initST</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    st.<span class="hljs-built_in">init</span>(height, len);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">query</span>(l, r);<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace SA</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cendec</title>
    <link href="/2022/03/31/Cendec/"/>
    <url>/2022/03/31/Cendec/</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们经常会遇到这样一类问题：  </p><p>求树上距离为 $k$ 的路径数/求树上与某点距离不大于 $k$ 的点的个数, $etc.$  </p><p>遇到这种问题，我们可以很自然地想到通过 dfs 加上容斥或是 dp 来解决这些问题。  </p><p>但是，我们发现，在朴素的 dfs 中,时间复杂度十分不稳定。要是碰到链的话，时间复杂度就会变为 $n^2$ 。因此，我们需要一个更加稳定的方法。</p><p>而点分治， aka 重心分治 (Centroid Decomposition) 就可以解决这个问题。</p><p>通过每次选取树的重心进行分治，我们可以保证我们最多只用 $n\log n$ 次即可解决问题。</p><p>因为树的重心拥有 “最大子树大小小于等于树的大小的 $\frac{1}{2}$ ” 的性质 ，因此我们可以保证只需 $\log n$ 个重心即可完成对所有子树的容斥 / dp。</p><p>下面我们来看几道题，来敲一敲点分治的板子  </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>先给一个点分治 <code>sol</code> 函数的基本写法  </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    judge[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    del[p] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">work</span>(p);<span class="hljs-comment">//有时会有容斥</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span>(!del[e-&gt;to])<br>        &#123;<br>            tot = siz[e-&gt;to];<br>            ctr = <span class="hljs-number">1</span>;<br>            mss[ctr] = maxk;<br>            <span class="hljs-built_in">getCtr</span>(e-&gt;to,p);<br>            <span class="hljs-built_in">sol</span>(ctr);<span class="hljs-comment">//递归处理子树重心</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="点分治（模板）"><a href="#点分治（模板）" class="headerlink" title="点分治（模板）"></a><a href="https://www.luogu.com.cn/problem/P3806">点分治（模板）</a></h3><p>这道题是要我们判断长度为 $k$ 的路径是否存在。</p><p>因此我们可以在分治时维护两个桶，一个记录其他子树上是否有长度为 $l$ 的边 (<code>judge</code>) ，一个记录当前树上都有长为多少的路径 (<code>tmp</code>) 。</p><p>具体实现及讲解在<a href="https://paste.ubuntu.com/p/HjRXnrxPFj/">这里</a></p><h3 id="聪聪可可"><a href="#聪聪可可" class="headerlink" title="聪聪可可"></a><a href="https://www.luogu.com.cn/problem/P2634">聪聪可可</a></h3><p>本题是记录模意义下的路径长为 3 的路径个数。<br>记 <code>p[3]</code> 为长度余数分别为 0,1,2 的路径</p><p>因此，最后答案的统计便是 $p_0<em>p_0+2</em>p_1*p_2$ 。每次在 <code>work</code> 函数计算即可。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a><a href="https://www.luogu.com.cn/problem/P6626">消息传递</a></h3><p>本题求的是距离某个点距离在 $k$ 以内的点的个数。</p><p>我们需要开个 <code>rev</code> 数组记录当前子树内的各个长度的路径的个数。<br>然后再对每个子树记录符合条件的路径数，但要先提前处理通过记录点的个数，然后在记录的过程中除去，最后再加上。<br>具体实现请看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; a[maxn];<br><span class="hljs-type">int</span> ans[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">updAns</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> tmp = a + p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pa : *tmp)<br>    &#123;<br>        <span class="hljs-type">int</span> k = pa.first - dep[p];<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        ans[pa.second] += rev[k];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">updAns</span>(p);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e = G::head[p]; e; e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span> (!del[e-&gt;to] &amp;&amp; e-&gt;to != fa)<br>            <span class="hljs-built_in">getAns</span>(e-&gt;to, p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    rev[dep[p]] += val;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e = G::head[p]; e; e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span> (!del[e-&gt;to] &amp;&amp; e-&gt;to != fa)<br>            <span class="hljs-built_in">remove</span>(e-&gt;to, p, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worK</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    dep[p] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">getDis</span>(p);<br>    <span class="hljs-built_in">updAns</span>(p);<span class="hljs-comment">//先对p单独统计</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e = G::head[p]; e; e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span> (!del[e-&gt;to])<br>        &#123;<br>            <span class="hljs-built_in">remove</span>(e-&gt;to, p, <span class="hljs-number">-1</span>);<span class="hljs-comment">//除去当前点的影响</span><br>            <span class="hljs-built_in">getAns</span>(e-&gt;to, p);<br>            <span class="hljs-built_in">remove</span>(e-&gt;to, p, <span class="hljs-number">1</span>);<span class="hljs-comment">//加回当前点的影响</span><br>        &#125;<br>    <span class="hljs-built_in">remove</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<span class="hljs-comment">//除去这棵子树上的信息</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20220314训练记录</title>
    <link href="/2022/03/14/20220314%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/14/20220314%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="2021省选"><a href="#2021省选" class="headerlink" title="2021省选"></a>2021省选</h2><h3 id="数对"><a href="#数对" class="headerlink" title="数对"></a><a href="https://www.luogu.com.cn/problem/P7517">数对</a></h3><p>直接扔到哈希表里记录枚举。<br>$0 \leq n \leq 2e5$ , $1 \leq a_i \leq 1e8$ ，因此 $n\log a$ 可过。</p><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a><a href="https://www.luogu.com.cn/problem/P7521">取模</a></h3><p>观察数据，发现答案的 $i,j,k$ 都集中在整个数列的最大的几个数。<br>因此我们可以将数列排列后直接选择前 $n$ 大的数进行枚举，即可通过。</p><p>考场上，面对这种题，我们骗分的时候，可以选择 <em>保证复杂度，同时尽量保证正确性</em> ，也可以 <em>保证正确性，同时尽量减少复杂度</em> 。</p><p>也就是说，当暴力的复杂度过高，难以通过，可以像这道题一样，通过观察得出一些结论，然后在保证复杂度的情况下得到尽可能多的分。<br>而减少复杂度则是一些对暴力的优化，如剪枝，或是一些题目规律。</p><h3 id="卡牌游戏"><a href="#卡牌游戏" class="headerlink" title="卡牌游戏"></a><a href="https://www.luogu.com.cn/problem/P7514">卡牌游戏</a></h3><p>我们可以发现，我们最终的目的是要通过翻面去消去尽量多的极大值和极小值，因此我们可以选择将 $2n$ 个数排成一行，用双指针扫。<br>在保证删掉的个数不大于 $m$ 且不同时删去同一张牌的情况下能删就删，就可以保证 $n\log n$ 做出。</p><h3 id="滚榜"><a href="#滚榜" class="headerlink" title="滚榜"></a><a href="https://www.luogu.com.cn/problem/P7519">滚榜</a></h3><p>本题为状压 dp 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Game-202202</title>
    <link href="/2022/02/18/Game-202202/"/>
    <url>/2022/02/18/Game-202202/</url>
    
    <content type="html"><![CDATA[<p>受师先生启发，记录一下最近玩的新游戏</p><h2 id="CloudPunk-云朋克"><a href="#CloudPunk-云朋克" class="headerlink" title="CloudPunk (云朋克)"></a>CloudPunk (云朋克)</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag:"></a>Tag:</h3><ul><li>模拟</li><li>赛博朋克</li><li>女性主角</li><li>像素艺术</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>玩法就是送货模拟器。作为主角，你可以在送货的途中驾驶飞车穿行于各类赛博朋克风建筑中观光，领略赛博朋克风格的美丽。</p><p>除了送货时开车和观光的乐趣以外，与 NPC 间的对话也是一个消费点。你可以在与不同 NPC 的对话中，或了解剧情，或感受城市中的冷暖人情，使你的游戏体验与这座城市充实起来。</p><p>如果你想感受一下听着歌，开着飞车，穿梭于霓虹灯与贫民窟之间送货，偶尔找个人聊聊天，捡捡垃圾的生活，那么你就一定要试试这款游戏。</p><h3 id="售价"><a href="#售价" class="headerlink" title="售价"></a>售价</h3><p>Steam上打折时本体 27.20元 ,一个 9小时 的 dlc 33.50元 。还行</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><h4 id="赛博朋克：酒保行动"><a href="#赛博朋克：酒保行动" class="headerlink" title="赛博朋克：酒保行动"></a><a href="https://zh.moegirl.org.cn/VA-11_Hall-A:%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%85%92%E4%BF%9D%E8%A1%8C%E5%8A%A8">赛博朋克：酒保行动</a></h4><p>同是赛博朋克风，同是模拟类游戏，同是靠对话撑起的剧情。</p><h4 id="欧卡模拟2"><a href="#欧卡模拟2" class="headerlink" title="欧卡模拟2"></a><a href="https://cn.bing.com/search?q=%E6%AC%A7%E5%8D%A1%E6%A8%A1%E6%8B%9F2">欧卡模拟2</a></h4><p>送货类模拟游戏，不用多说。</p><h2 id="Heart-of-Iron-4-（HOI4-钢铁雄心4）"><a href="#Heart-of-Iron-4-（HOI4-钢铁雄心4）" class="headerlink" title="Heart of Iron 4 （HOI4 钢铁雄心4）"></a>Heart of Iron 4 （HOI4 钢铁雄心4）</h2><p><del>小胡子养成计划4</del></p><h3 id="Tag-1"><a href="#Tag-1" class="headerlink" title="Tag:"></a>Tag:</h3><ul><li>模拟</li><li>军事</li><li>战棋类游戏</li><li><del>历史虚无主义</del></li></ul><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>著名的 <strong>P社4萌</strong> 之一。</p><blockquote><p>“P社”指 Paradox Interactive</p></blockquote><p>本游戏的背景是从 1931 年开始的二战模拟。你可以选择大部分国家进行游戏。</p><p>在经营国家时，无论文武，你都可以自主进行选择：</p><p>是选择钢铁洪流碾过敌军，还是 “9步1炮” 一点点平推，还是攻击机舔地。</p><p>是延展马奇诺防线，还是开局法国登陆英国，让德三无路可走。</p><p>是选择复辟法兰西第三帝国、大清、神圣罗马帝国，还是 “未曾设想的道路”。</p><p>是选择加入小胡子，还是 “攘外安内”。</p><p>或是选择AI看海……</p><p>一切的历史，都由你来选择。</p><h3 id="售价-1"><a href="#售价-1" class="headerlink" title="售价"></a>售价</h3><p>Steam锁国区，因此我选择了学习版。</p><p>分享一下下载地址： <a href="https://www.sharelikes.cn/?ivk_sa=1024320u">傻狗本狗的小破站</a></p><h3 id="相关推荐-1"><a href="#相关推荐-1" class="headerlink" title="相关推荐"></a>相关推荐</h3><h4 id="剩下的三萌："><a href="#剩下的三萌：" class="headerlink" title="剩下的三萌："></a>剩下的三萌：</h4><ul><li>VC2(Victoria 2 维多利亚2)</li><li>CK系列(Crusader Kings 十字军之王 <del>中世纪孟德尔</del>)</li><li>EU4( Europa Universalis 4 欧陆风云4) </li></ul><p>对了，还有个群星(Stellaris)（</p><h4 id="席德梅尔的文明VI-（Sid-Meier’s-Civilization-VI）"><a href="#席德梅尔的文明VI-（Sid-Meier’s-Civilization-VI）" class="headerlink" title="席德梅尔的文明VI （Sid Meier’s Civilization VI）"></a>席德梅尔的文明VI （Sid Meier’s Civilization VI）</h4><p>也是经典的战棋类游戏，只不过这个是 4x 类战棋，还有探索和扩张要素，跟群星更像。</p><h4 id="世界征服者系列"><a href="#世界征服者系列" class="headerlink" title="世界征服者系列"></a>世界征服者系列</h4><p>虽然自己没玩过，但是这也是国内为数不多的可以对标P社的游戏公司了。</p><p>这个基本就是HOI4的简化版，可以先从这个入门试试。</p><h2 id="DeadCell-（死亡细胞）"><a href="#DeadCell-（死亡细胞）" class="headerlink" title="DeadCell （死亡细胞）"></a>DeadCell （死亡细胞）</h2><h3 id="Tag-2"><a href="#Tag-2" class="headerlink" title="Tag:"></a>Tag:</h3><ul><li>RougeLike</li><li>像素艺术</li><li>奇幻</li><li>横版动作</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>十分著名的RougeLike动作游戏，动作十分流畅，观赏性极强，玩起来十分爽快。</p><p>没什么好说的。</p><h3 id="售价-2"><a href="#售价-2" class="headerlink" title="售价"></a>售价</h3><p>学习版……</p><h3 id="相关推荐-2"><a href="#相关推荐-2" class="headerlink" title="相关推荐"></a>相关推荐</h3><p>Hades (哈迪斯) 也是一个著名的RougeLike动作游戏，IGN给了9分，棒！</p><h2 id="CupHead-茶杯头"><a href="#CupHead-茶杯头" class="headerlink" title="CupHead (茶杯头)"></a>CupHead (茶杯头)</h2><h3 id="Tag："><a href="#Tag：" class="headerlink" title="Tag："></a>Tag：</h3><ul><li>双人</li><li>复古</li><li>魂系</li><li>卡通</li><li>横版射击</li></ul><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>整个游戏的画风与配乐都是模仿的美国早期漫画风格，同时难度较难，喜欢受苦的同学有福了。</p><p>剧情为茶杯头兄弟欠了债，要么帮债主讨回其他人的欠款，要么出卖灵魂……（老套设定</p><p>这个剧情基本等于没有，反正受苦开心就好了！</p><p>对了，这玩意和生化危机一样，没血条，所以初见还是很有紧张感的。</p><h3 id="售价-3"><a href="#售价-3" class="headerlink" title="售价"></a>售价</h3><p>学习版</p><h3 id="相关推荐-3"><a href="#相关推荐-3" class="headerlink" title="相关推荐"></a>相关推荐</h3><p>其他的没什么能说的，就举几个魂系列的游戏吧： </p><h4 id="宫崎英高的恶意"><a href="#宫崎英高的恶意" class="headerlink" title="宫崎英高的恶意"></a><del>宫崎英高的恶意</del></h4><p>黑暗之魂123，只狼：影逝二度，艾尔登法环</p><h4 id="血源：诅咒，"><a href="#血源：诅咒，" class="headerlink" title="血源：诅咒，"></a>血源：诅咒，</h4><p>融合了克苏鲁的魂系游戏</p><h4 id="遗迹：灰烬重生"><a href="#遗迹：灰烬重生" class="headerlink" title="遗迹：灰烬重生"></a>遗迹：灰烬重生</h4><p>用枪的魂系游戏</p><blockquote><p>小科普：什么是传统意义上魂系游戏呢？我认为有这样几个特点：</p><ul><li>场景多为中世纪风格的遗迹</li><li>Boss战前有雾门</li><li>难度极高，基本小兵都能当精英怪打</li></ul><p>当然。现在的魂系游戏，一般都单指难度极高了，剩下的能对上更好</p></blockquote><h2 id="Metal-Gear-Solid-：-Peace-Walker-合金装备：和平行者"><a href="#Metal-Gear-Solid-：-Peace-Walker-合金装备：和平行者" class="headerlink" title="Metal Gear Solid ： Peace Walker (合金装备：和平行者)"></a>Metal Gear Solid ： Peace Walker (合金装备：和平行者)</h2><p><del>其实官方译名是潜龙谍影</del></p><h3 id="Tag：-1"><a href="#Tag：-1" class="headerlink" title="Tag："></a>Tag：</h3><ul><li>潜入 谍报 动作 （雾</li><li>剧情向</li><li>养成</li></ul><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>这是小岛秀夫在推出 合金装备：食蛇者 之后的作品。它在系统上做出了较大的改动，基本奠定了 5 代的系统（剧情上也是）。</p><p>因此，这部作品对于我这种五代入坑的玩家就较为友好，难度也较低。</p><p>合金装备的一大特点就是有各种黑科技及小道具，可以玩出很多花活。最经典，如纸箱潜入和富尔顿回收（这一作首次提出）。</p><p>小岛的恶趣味有时也会让人眼前一亮。比如5代前每作必有的，让游戏中的角色一本正经的说出 “按下动作键” 之类的台词。</p><p>总之，这是一部不错的潜行游戏，值得一玩。</p><h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>PSP上的老游戏，当然只能学习版了……</p><h3 id="相关推荐-4"><a href="#相关推荐-4" class="headerlink" title="相关推荐"></a>相关推荐</h3><h4 id="AC系列-assassin-Creed"><a href="#AC系列-assassin-Creed" class="headerlink" title="AC系列(assassin Creed)"></a>AC系列(assassin Creed)</h4><p>育碧的经典潜入游戏，不用多说。当然，从神话系列开始，潜行就只是添头了，因此可以找前面的几作游玩。</p><h3 id="汤姆克兰西的细胞分裂系列-（Tom-Clancy’s-Splinter-Cell）"><a href="#汤姆克兰西的细胞分裂系列-（Tom-Clancy’s-Splinter-Cell）" class="headerlink" title="汤姆克兰西的细胞分裂系列 （Tom Clancy’s Splinter Cell）"></a>汤姆克兰西的细胞分裂系列 （Tom Clancy’s Splinter Cell）</h3><p>推荐这个是因为当初育碧就是对标合金装备出的这个，所以肯定是一类……</p><p>二月游戏就新玩了这么点，大家看着有什么想玩的就快玩吧，毕竟返校就在眼前。</p>]]></content>
    
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上下界网络流</title>
    <link href="/2022/02/11/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2022/02/11/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>上下界网络流可以看做普通网络流的进阶版。因为我们不仅要关注每条边流量的最大值，还要关注其最小值。</p><p>那么，我们就从一般到特殊，来看一看如何解决这种问题吧。</p><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><pre><code class=" mermaid">graph LR    A--&gt;|1,3|B    A--&gt;|2,4|C    C--&gt;|1,4|D    B--&gt;|1,3|E    E--&gt;|2,3|D    D--&gt;|3,4|A    D--&gt;|2,5|B</code></pre><p>这是最普通的情况了：没有源汇、每条边的流量满足上下限即可。</p><p>那么我们该如何解决这个问题呢?</p><p>我们可以将原图拆成两个网络：下界网络与差网络。</p><p>在下界网络中，每条边的流量为原图的下界：</p><pre><code class=" mermaid">graph LR    A--&gt;|1|B    A--&gt;|2|C    C--&gt;|1|D    B--&gt;|1|E    E--&gt;|2|D    D--&gt;|3|A    D--&gt;|2|B</code></pre><p>而在差网络中，每条边的流量是上界与下界之间的差：</p><pre><code class=" mermaid">graph LR    A--&gt;|2|B    A--&gt;|2|C    C--&gt;|3|D    B--&gt;|2|E    E--&gt;|1|D    D--&gt;|1|A    D--&gt;|3|B</code></pre><p>为什么要这么拆呢？因为我们首先要满足下界的条件，也就是使下界网络满流。</p><p>然后再加上差网络的最大流，得到原网络的一个可行流。</p><p>但这样处理后，我们会发现，对于每个点来说，“进”可能不等于“出”了。</p><p>如下界网络中的 C 点，进 2 ，出 1 ，这显然是不合理的，因此我们需要用差网络去补足这些流量。</p><p>那么我们该如何对差网络进行修改呢？</p><p>我们可以这么干：</p><p>首先，新建一个源点，一个汇点。</p><p>其次对于每个点，设 $x$ 为 “进-出” 。</p><p>最后：若</p><ul><li>$x&gt;0$ 时，我们从源点向该点连一条流量为 $x$ 的边。</li><li>$x&lt;0$ 时，我们从该点向汇点连一条流量为 $x$ 的边。</li><li>$x=0$ 时，我们很开心，不用管它</li></ul><p>为什么这么修改对呢？</p><p>因为这样就可以在差网络中表现出下界网络中多流的或少流的在差网络中偿还回来。</p><p>修改后的图如下： </p><pre><code class=" mermaid">graph LR    S--&gt;|2|B &amp; C--&gt;|3|D    A--&gt;|2|B    B--&gt;|2|E    A--&gt;|2|C    E--&gt;|1|D    E--&gt;|1|T    D--&gt;|2|T    D--&gt;|1|A    D--&gt;|3|B</code></pre><p>这样，我们在差网络上跑出来的最大流，加上下界网络，就是一个可行流了。  </p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><p>和上面差不多。我们可以先将源点与汇点看做两个普通点。从汇点到源点连一条下界为 $0$ ，上界为 $\infty$ 的附加边，得到一张和原图等价的无源汇流量网络，然后建立下界网络与差网络。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>因为我们之前求的可行流已经保证了流量平衡。因此，我们可以删去与新建的源汇相连的边，然后再跑一遍最大流即可。因为之前流量已平衡，再次跑最大流不会破坏它的性质。</p><h2 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a>有源汇有上下界最小流</h2><p>跟上面几乎完全相同，只需要在拆掉附加边后，从汇点到源点，而不是从源点到汇点跑一遍最大流。可行流的流量，减去从汇点到源点的最大流即为答案。</p><p>这么做的原理与（有源汇上下界）最大流类似，如果增加流量不会破坏性质，那么减少自然也不会。</p><h2 id="有上下界最小费用可行流"><a href="#有上下界最小费用可行流" class="headerlink" title="有上下界最小费用可行流"></a>有上下界最小费用可行流</h2><p>和（无/有源汇）有上下界可行流的原理相同，也是拆成两个网络。所有附加边的费用设为 0 。最后的费用是下界网络满流的费用，加上在差网络上跑 MCMF 后得到的费用之和。而前者即所有边的容量与费用乘积的和。</p><p>注意，这样求出来的是满足最小费用的可行流，而不是满足流最大的前提下费用最小的流。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记——一月</title>
    <link href="/2022/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-20220209/"/>
    <url>/2022/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-20220209/</url>
    
    <content type="html"><![CDATA[<h2 id="严肃文学"><a href="#严肃文学" class="headerlink" title="严肃文学"></a>严肃文学</h2><h3 id="媒介批判三部曲"><a href="#媒介批判三部曲" class="headerlink" title="媒介批判三部曲"></a><a href="/sbq.mobi">媒介批判三部曲</a></h3><p>听着名字十分的高大上，但其实核心就是从媒介的变化的角度，对当今社会的一些现象做出解释。</p><p>其实里面的很多东西，你也可能说出来，但是不一定能像作者一样条理清晰地，详实地写出来，因此还是值得一看的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24Problem</title>
    <link href="/2022/02/09/24Problem/"/>
    <url>/2022/02/09/24Problem/</url>
    
    <content type="html"><![CDATA[<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="飞行员配对方案问题"><a href="#飞行员配对方案问题" class="headerlink" title="飞行员配对方案问题"></a><a href="https://www.luogu.com.cn/problem/P2756">飞行员配对方案问题</a></h3><p>本题是一道裸的 二分图最大匹配 ， $\mathcal{O}(n^3)$ 匈牙利或者 $\mathcal{O}(n^2m)$ 即可。</p><h3 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a><a href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a></h3><p>观察题意，我们发现，本题要求的 “取数的和最大” 可以容易地转化为 “不取的数和最小”。</p><p>而在网络流中满足 “不取的数和最小” 的名词，那便自然是 “最小割” 了。</p><p>那么该如何建图呢？我们可以发现，原图中的点集只有两种情况： 选或不选。同时，一定会有一些点对，选其中的一个是不影响另一个店选与不选的状态的。而这，正好符合二分图的定义：点集内的点不可相互访问到。</p><p>因此，我们可以考虑按一定的规则分类，（如按坐标和的奇偶），然后建二分图，跑最大流。</p><h3 id="试题库问题"><a href="#试题库问题" class="headerlink" title="试题库问题"></a><a href="https://www.luogu.com.cn/problem/P2763">试题库问题</a></h3><p>直接按照题意，建二分图，从试题向类型连边，然后跑最大流。</p><h3 id="最长不下降子序列问题"><a href="#最长不下降子序列问题" class="headerlink" title="最长不下降子序列问题"></a><a href="https://www.luogu.com.cn/problem/P2766">最长不下降子序列问题</a></h3><p>本题有三问： 第一问是正常的 LIS ，第二问是所有元素只能用一次的LCS个数，第三问是第一个和最后一个元素无限用的LCS个数。</p><p>首先，在第一问我们需 $\mathcal{O}(n^2)$ 地求出LCS与其 $F$ 数组， $F[i]$ 代表以 $i$ 位置开头的 LCS 长度。</p><p>然后在二，三问中按 $F[i]$ 进行分层。然后控制一下源点和终点的流量为(1,1)和( $\infin,\infin$ )后跑最大流即可。</p><h3 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a><a href="https://www.luogu.com.cn/problem/P2765">魔术球问题</a></h3><p>对于每一个球，它只可能有两种情况：新开一列，或者连到之前的一列。因此，我们可以选择讲一个点 $p$ 拆成两个点 $p,p’$ ,然后将 $s$ 连向 $p$ , $p’$ 连向 $t$ ,然后满足条件的点再分别与点 $p$ 连边，然后再跑最大流即可。</p><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><h3 id="汽车加油行驶问题"><a href="#汽车加油行驶问题" class="headerlink" title="汽车加油行驶问题"></a><a href="https://www.luogu.com.cn/problem/P4009">汽车加油行驶问题</a></h3><p>本题就是分层图的最小费用最大流，直接建分层图跑即可。</p><h3 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a><a href="https://www.luogu.com.cn/problem/P4015">运输问题</a></h3><p>裸的最小费用最大流。</p><h3 id="深海机器人问题"><a href="#深海机器人问题" class="headerlink" title="深海机器人问题"></a><a href="https://www.luogu.com.cn/problem/P4012">深海机器人问题</a></h3><p>最大费用最大流，做的时候边权取负即可。</p><h3 id="餐巾计划问题"><a href="#餐巾计划问题" class="headerlink" title="餐巾计划问题"></a><a href="https://www.luogu.com.cn/problem/P1251">餐巾计划问题</a></h3><p>本题依然是最小费用最大流，但是建图时需要注意一下:</p><ul><li>因为每天早上收到毛巾，晚上输出，因此可将一天拆成早晚。</li><li>每天早晨向汇点连一条流量为 $INF$ ，费用为 $0$ 的边，代表毛巾的供应。</li><li>代表当天买的干净毛巾流量直接从源点连向每天早晨，流量为 $INF$ ，费用为买毛巾的费用。</li><li>代表每天输出的脏毛巾同样从源点连向每天晚上，流量为 $x$ ，费用为 $0$ 。</li><li>代表快洗与慢洗的流量都从当天的晚上流向对应的天数的早上。</li><li>相邻两天的夜晚连一条边，流量为 $INF$ ，费用为 $0$ 。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐子乐子</title>
    <link href="/2022/01/14/%E4%B9%90%E5%AD%90%E4%B9%90%E5%AD%90/"/>
    <url>/2022/01/14/%E4%B9%90%E5%AD%90%E4%B9%90%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="乐子"><a href="#乐子" class="headerlink" title="乐子"></a>乐子</h2><p>快过年了，不要再讨论什么C++，离散数学，数据结构与算法之类的了，你带你的C++ Primer与CSAPP回到家并不能给你带来任何实质性作用，朋友们打开Python敲两下就做出了大整数四则运算，你默默的在家里瞪着两眼看五颜六色的WA,RE,CE,MLE,UKE。</p><p>亲戚朋友们吃饭问你收获了什么，你说我读完了混凝土数学和算法导论，系统的研究了多项式科技，还用OOP重构了自己的猪国杀。亲戚们懵逼了，你还在心里默默嘲笑他们，笑他们不懂C++和面向对象编程，不懂lambda，不懂常系数非齐次线性递推和LCT，也笑他们连迭代器是什么都不知道。</p><p>你父母的同事都在说自己儿女一年的收获，有的用Java做了个MC服务器后和朋友远程同乐，有的用Python做了点数据可视化发到B站成了up主，有的学了Unity和C#做独立游戏已经发售了。</p><p>你的父母默默无言，说我的儿子买了一整套的Effective C++，上Stack Overflow痛骂了C++标准委员会，写了一堆狗屁不通报错几百几千行的指针的代码，还对着谷歌翻译啃um_nik的binary search，人也越来越魔怔了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://zhuanlan.zhihu.com/p/456526193">SnowyLake</a><br><a href="https://www.zhihu.com/question/506799934/answer/2290792445">不要被和谐</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZFunction&amp;SA(M)</title>
    <link href="/2022/01/12/ZFunction/"/>
    <url>/2022/01/12/ZFunction/</url>
    
    <content type="html"><![CDATA[<h2 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h2><p>Z函数所表示的，为字符串 $s$ 的一个后缀串 $t$ 与其的 <strong>最长公共前缀</strong> ，即LCP （Longest Common Prefix）。  </p><p>形式化来说，设 $sa(i)$ 为 $s[i,…,n-1]$ 这个后缀，则 $z[i] = lcp(s,sa(i))$ .</p><p>这个东西可以有什么应用呢？</p><p>首先，我们来看它在洛谷上的<a href="https://www.luogu.com.cn/problem/P5410">模板题</a>  </p><p>可以发现，这是求LCP长度的裸题，因此直接使用z函数的定义，通过跑扩展KMP实现。  </p><p>学会了基础运用之后，接下来就是进阶应用了，我总结了有以下几点：</p><ol><li>字符串的循环节  </li></ol><p>考虑计算原串的 Z 函数，则其整周期的长度为最小的 $n$ 的因数 $i$，满足 $i+z[i]=n$ 。</p><p>即可得出答案。  </p><blockquote><p>例题:</p><ol><li><a href="https://www.luogu.com.cn/problem/UVA455">UVa455</a></li><li><a href="https://www.luogu.com.cn/problem/UVA11022">UVa11022</a></li></ol></blockquote><p>同时，若我们把 $n$ 换成 $|s|$ ,即可求出 $s$ 的所有 border。  </p><blockquote><p>注意，与KMP不同的是，这里求的是“所有border”，而不是“所有前缀的border”。</p></blockquote><ol><li>出现位置</li></ol><p>给出文本串 $s$ 和模式串 $p$ ，求 $p$ 在 $s$ 中的所有出现位置。<br>这是KMP和字符串哈希的经典题目，但也可以用Z算法。设 $$ $ 为字符集外字符，求 $p+$+p$ 的Z函数，则每一个 $z[i]=|p|$ 都对应 $p$ 在 $s$ 中的一次出现。</p><blockquote><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/CF126B">CF126B</a></p></blockquote><ol><li>求 $s$ 的每个前缀的出现次数</li></ol><p>求 $s$ 的Z函数。对于每一个 $i$ ，如果 $z[i]$ 不等于0，说明长度为 $z[i],z[i-1],…,1$ 的前缀在此处各出现了一次，所以求一个后缀和即可。在这个问题中一般令 $z[0]=|s|$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>; ++i)<br>    S[z[i]]++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i)<br>    S[i] += S[i + <span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><blockquote><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/CF432D">CF432D</a></p></blockquote><h2 id="SA-amp-SAM"><a href="#SA-amp-SAM" class="headerlink" title="SA&amp;SAM"></a>SA&amp;SAM</h2><h3 id="SA-Suffix-Array"><a href="#SA-Suffix-Array" class="headerlink" title="SA(Suffix Array)"></a>SA(Suffix Array)</h3><blockquote><p><a href="./1.pdf">参考资料-2009论文</a></p></blockquote><p>顾名思义，SA（后缀数组）是一种与字符串的后缀有关的数据。</p><p>这里我们先定义几个概念：</p><blockquote><p>以下皆为 0-index</p></blockquote><ol><li>$SA(i)$ 表示 $s[i,…,n-1]的排名(rank)$ ,所以我们也可以将 “$i$“ 理解为一个字符串。</li><li>LCP[i] 表示 $lcp(sa(i),sa(i+1))$ 的长度 ,也就是相邻两个后缀的 $lcp$ 的长度。</li><li>LCP(i,j) 表示若 $rank[i]&lt;rank[j]$ $min(LCP[rank[i] ],…,LCP[rank[j]-1 ]  )$ ,也就是一个区间RMQ问题。</li></ol><p>那么，它有什么应用呢？  </p><p>首先是<a href="https://www.luogu.com.cn/problem/P3809">模板题</a>。</p><p>这道题的核心主要是排序算法的选择。因为值域确定，因此此时选择类似桶排的 $\mathcal{O}(nk)$ （k一般为ASCII码的值域，即128）就会更快。</p><blockquote><p>亲测，开O2后，std::sort 6.1秒，而基数排序则只有 0.6秒，快了不止10倍。</p></blockquote><p>因此，它可以在 $\mathcal{O}(n\log n)$ 的时间内解决后缀的排序。（倍增的 $\log n \times$  遍历的 $n$ ）</p><p>同时，还有一种 <em>DC3</em> 算法，可以 $\mathcal{O}(n)$ 求SA，但编码难度更大。</p><p>那么，除了求SA数组，它还有其他的应用吗？  </p><p>下面就是一些例字。  </p><ol><li>求两个后缀的LCP。求法在上面的概念3中。</li><li>求本质不同的字符串的数量：<br>我们可以按字典序遍历所有本质不同的子串。<br>只需要遍历 $sa(1)$ 的前缀，但是跳过前 $lcp[i]$ 个，因为这 $lcp[i]$ 个前缀是与 $sa(i-1)$ 共有的，之前一定已经被遍历过了。<br>按此道理，也可以知道字符串本质不同的子串数量为 $\frac{n(n-1)}{2}-\Sigma LCP[i]$ 。</li><li>…</li></ol><p>以下为一些例题：</p><ol><li><p><a href="https://www.luogu.com.cn/problem/P2852">Milk Patterns G</a><br> 这可以算是一道SA的裸题了。观察要求的答案，发现求一个在原串中出现 $k$ 次的子串 ，相当于找 $k$ 个后缀求LCP。<br> 因此，答案必定是 $k$ 个 $LCP[i]$ 的最小值，因此这 $k$ 个后缀的 $rank$ 一定是连续的，因此可用单调队列解决 。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P4051">JSOI2007</a><br> 也是一道裸题，讲串扩大2倍后跑SA即可。<br> 为什么这样对呢》因为对于求出的后缀来说，最后多出的后缀等价于它自己的前缀，因此不会对排名造成影响。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2336">SCOI2012</a><br> 首先建出SA，发现对于每个点名，我们可以通过二分找出其被选择的区间，然后第一问就转化成了HH的项链，可以用树状数组解决<br> 而对于第二问，我们可以选择访问到L处给树状数组data[L]++,到R时data[L]—,到i时查询sum(i)-sum(pre[i])， 和第一问相反.</p></li><li><p><a href="https://www.luogu.com.cn/problem/P5546">POI2000</a><br>  思想是拼接字符串，并使用字符集外字符隔开，然后跑SA。<br>  那么问题实际上转化为：在 $\texttt{lcp}$ 数组上找连续的一段，使得这一段包含来自给定的每个字符串的至少一个后缀.<br>  这个问题便可类比滑动窗口使用单调队列解决。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2463">SD2008</a><br>  先用分隔符连接所有字符串后求SA数组，然后二分长度得出答案。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P1117">NOI2016</a><br>  字符串哈希+SA+ST表 $\mathcal{O}(1)$ 查询LCP。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2178">NOI2015</a><br> 推到式子的最后一步，我们发现，贡献与 $\texttt{height}$ 的连续段大小关系有关。<br> 所以直接把 $\texttt{height}$ 从大到小排序，每次处理一个 $\texttt{height}$ 就合并两个集合并且计算产生的贡献。<br> 最后求一个后缀和就好</p></li></ol><h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>SAM(Suffix Automaton) 是一种强大的解决字符串相关问题的数据结构。  </p><p>它通过维护不同后缀的 $\text{endpos}$ 来在 $\mathcal{O}(n)$ 空间， $\mathcal{O}(n|\Sigma|)$ ( $\Sigma$ 为字符集大小)内构建，并解决一些问题。  </p><p>同时，因为在实现时，时空复杂度主要由 <code>Node</code> 中的 <code>std::map&lt;char,int&gt;</code> 来决定，所以想要空间换时间的话，就可以把 <code>map</code> 换成 <code>__gnu_pbds::gp_hash_map&lt;char,int&gt;</code> ，或者换成“数组+链表”。  </p><blockquote><p>多说一句： 不要写指针！！！因为可能会有一些阴间出题人去卡你的空间……</p></blockquote><p>它可以做到许多事情，以下为一些例题以及用SAM实现的功能</p><ol><li><p>子串出现次数<br> <a href="https://www.luogu.com.cn/problem/P3804">模板题</a> 裸的模板题<br> <a href="https://loj.ac/p/2033">SDOI2016</a> 裸的模板题</p></li><li><p>第 k 大子串<br> 因为字典序第 $k$ 大的子串对应于 SAM 中字典序第 $k$ 大的路径，因此在计算每个状态的路径数后，我们可以很容易地从 SAM 的根开始找到第 $k$ 大的路径。<br> <a href="https://www.luogu.com.cn/problem/P3975">TJOI2015</a> 这道题求的是第k小，没有区别  </p></li><li><p>两个串的最长公共前缀<br> <a href="https://www.luogu.com.cn/problem/P4248">AHOI2013</a> 这道题求的是两两串的最长公共前缀长度和。因为SAM为树，因此问题就被转化为了LCA问题，即可解决。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>严肃文学</title>
    <link href="/2021/12/25/%E4%B8%A5%E8%82%83%E6%96%87%E5%AD%A6/"/>
    <url>/2021/12/25/%E4%B8%A5%E8%82%83%E6%96%87%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="严肃文学"><a href="#严肃文学" class="headerlink" title="严肃文学"></a>严肃文学</h2><h2 id="2021-12-25"><a href="#2021-12-25" class="headerlink" title="2021.12.25"></a>2021.12.25</h2><h3 id="马克思1844年经济学哲学手稿"><a href="#马克思1844年经济学哲学手稿" class="headerlink" title="马克思1844年经济学哲学手稿"></a><a href="./1844.pdf">马克思1844年经济学哲学手稿</a></h3><p>梦开始的地方。</p><p>马克思著作，里面的关于异化劳动的部分看完后对理解现在的社会十分具有指导意义。</p><p>这本书是马克思从国民经济学的角度出发，一步步剖析资本主义社会中的社会现实，</p><h3 id="政治学通识"><a href="#政治学通识" class="headerlink" title="政治学通识"></a><a href="./ZZXTS.mobi">政治学通识</a></h3><p>这是一本讲解一些政治的最基本的知识的科普读物。  </p><p>你知道政治的定义是什么吗，国家的定义呢。<br>你知道你知道都有哪些政体吗，你知道每种政体的特征是什么吗，你知道民主政体有几种吗？<br>你知道选举都有哪些方式吗，又有哪些方式来实现选举的公平呢？</p><p>这些答案，都在这本书中。  </p><h3 id="寡头统治铁律"><a href="#寡头统治铁律" class="headerlink" title="寡头统治铁律"></a><a href="./GTTZTL.mobi">寡头统治铁律</a></h3><p>政治学通识的推荐读物。</p><p>作者结合了在德国的社会主义工人党工作时的所见所闻与思考，将他的主要思想加以扩展与论证，写成了这本书。</p><p>作者的主要观点，便是在一个组织中，尤其是大规模的组织中，直接民主会越来越难实现。因为随着对于执行间接民主的人的专业性或是某一方面的特殊才能的要求越来越高，普通人将会越来越难以在民主过程中发挥作用。因此，至少在作者眼中看来，现有的民主体系，最后都会不可避免地将权力集中在少数人手中。这，便是作者口中的“寡头统治铁律”。</p><h3 id="发条橙"><a href="#发条橙" class="headerlink" title="发条橙"></a><a href="./FTC.mobi">发条橙</a></h3><p>经典的反乌托邦小说  </p><p>如果要看的话，前半段关于犯罪的描写可以快速跳过，你只需要知道主角很坏就行了。</p><p>主旨基本就是，如果一个人无理由地选择“善”，失去了选择地权力，那他还算一个人吗。</p><h3 id="美丽新世界-amp-重返美丽新世界"><a href="#美丽新世界-amp-重返美丽新世界" class="headerlink" title="美丽新世界&amp;重返美丽新世界"></a><a href="./MLXSJ.mobi">美丽新世界&amp;重返美丽新世界</a></h3><p>经典反乌托邦小说  </p><p>比《1984》更接近于现在的世界。相较于《1984》的使用刑罚与严格的言论控制来实行思想管制，《美丽新世界》使用了更加现代化的方法：药物控制（苏摩）；大量的神奇娱乐（各种神奇的高尔夫与球类运动……）；鼓励多参加群体运动，而不是一个人思考；睡眠时的教育；开放的性。当然，最重要的是出生时就被决定了的等级：从高等阿尔法到低等埃普西隆，以及与之配套的各个阶级分开的教育。同时，诸如莎士比亚的名著等经典作品都成了只有统治阶级才能拥有的禁书。</p><p>所以，你会发现，《1984》中所描绘的集权警察社会早已落伍。《美丽新世界》才是一个对现在的社会更有意义的作品。  </p><p>同时，作者还在《重返美丽新世界》里，以一个作家的身份，去思考了一些社会现实。建议读完《政治学通识》再来看这个，收获会更大。</p><h3 id="围城"><a href="#围城" class="headerlink" title="围城"></a>围城</h3><p>钱钟书经典小说。</p><p>看方渐鸿踩过的坑，自己少踩一点……</p><blockquote><p>Last upd:2021.12.25  </p></blockquote><hr>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>娱乐文学</title>
    <link href="/2021/12/25/%E5%A8%B1%E4%B9%90%E6%96%87%E5%AD%A6/"/>
    <url>/2021/12/25/%E5%A8%B1%E4%B9%90%E6%96%87%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="娱乐文学"><a href="#娱乐文学" class="headerlink" title="娱乐文学"></a>娱乐文学</h2><h2 id="2021-12-25"><a href="#2021-12-25" class="headerlink" title="2021.12.25"></a>2021.12.25</h2><h3 id="狼与香辛料"><a href="#狼与香辛料" class="headerlink" title="狼与香辛料"></a><a href="https://zh.moegirl.org.cn/%E7%8B%BC%E4%B8%8E%E9%A6%99%E8%BE%9B%E6%96%99">狼与香辛料</a></h3><p>公路狗粮番，看老夫老妻秀恩爱就行了。</p><p>男主与女主的成长也是一个看点</p><h3 id="未闻花名-我们仍未知道那天所见到的花的名字"><a href="#未闻花名-我们仍未知道那天所见到的花的名字" class="headerlink" title="未闻花名(我们仍未知道那天所见到的花的名字)"></a>未闻花名<a href="https://zh.moegirl.org.cn/%E6%88%91%E4%BB%AC%E4%BB%8D%E6%9C%AA%E7%9F%A5%E9%81%93%E9%82%A3%E5%A4%A9%E6%89%80%E7%9C%8B%E8%A7%81%E7%9A%84%E8%8A%B1%E7%9A%84%E5%90%8D%E5%AD%97">(我们仍未知道那天所见到的花的名字)</a></h3><p>经典催泪轻小说，讲述了主角团中的一位因事故身亡的同年玩伴，面码(本间芽衣子)，在主角团长大后，灵魂又回到人间，因此展开的一系列为了实现她的愿望而发生的主角团之间的故事。</p><h3 id="PsychoPass前传"><a href="#PsychoPass前传" class="headerlink" title="PsychoPass前传"></a>PsychoPass前传</h3><p>著名反乌托邦动画<a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85">PsychoPass</a>的第一部的前传小说。  </p><p>讲述了男主，<a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">监视官</a> <a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85/%E8%A7%92%E8%89%B2%E5%88%97%E8%A1%A8"><em>狡啮慎也</em></a> 与他的前任执行官，佐佐山光留，为了追捕一名将人体做为“艺术品”的罪犯而发生的故事。  </p><p>佐佐木在追捕过程中丧命，而这就是是男主从一名监视官降级成执行官的原因。</p><h3 id="末日三问-末日时在做什么-有没有空-可以来拯救吗"><a href="#末日三问-末日时在做什么-有没有空-可以来拯救吗" class="headerlink" title="末日三问(末日时在做什么?有没有空?可以来拯救吗?)"></a>末日三问<a href="https://zh.moegirl.org.cn/%E6%9C%AB%E6%97%A5%E6%97%B6%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%3F%E6%9C%89%E6%B2%A1%E6%9C%89%E7%A9%BA%3F%E5%8F%AF%E4%BB%A5%E6%9D%A5%E6%8B%AF%E6%95%91%E5%90%97%3F">(末日时在做什么?有没有空?可以来拯救吗?)</a></h3><p>异世界日常，治愈（确信）。</p><p>其中“妖怪兵器”为不惧死亡的幼女（雾）的设定还是比较新颖的。</p><h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>经典治愈番的同名小说，不多解释。  </p><h3 id="球状闪电"><a href="#球状闪电" class="headerlink" title="球状闪电"></a>球状闪电</h3><p>刘慈欣经典小说  </p><p>讲述了一名醉心于研究武器的女少校林云在发现“球状闪电”这种武器后发生的一系列故事。</p><blockquote><p>Last upd: 2021.12.25</p></blockquote><hr>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记-211225</title>
    <link href="/2021/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-211225/"/>
    <url>/2021/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-211225/</url>
    
    <content type="html"><![CDATA[<h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h2 id="严肃文学"><a href="#严肃文学" class="headerlink" title="严肃文学"></a>严肃文学</h2><h3 id="马克思1844年经济学哲学手稿"><a href="#马克思1844年经济学哲学手稿" class="headerlink" title="马克思1844年经济学哲学手稿"></a><a href="./1844.pdf">马克思1844年经济学哲学手稿</a></h3><p>梦开始的地方。</p><p>马克思著作，里面的关于异化劳动的部分看完后对理解现在的社会十分具有指导意义。</p><p>这本书是马克思从国民经济学的角度出发，一步步剖析资本主义社会中的社会现实，</p><h3 id="政治学通识"><a href="#政治学通识" class="headerlink" title="政治学通识"></a><a href="./ZZXTS.mobi">政治学通识</a></h3><p>这是一本讲解一些政治的最基本的知识的科普读物。  </p><p>你知道政治的定义是什么吗，国家的定义呢。<br>你知道你知道都有哪些政体吗，你知道每种政体的特征是什么吗，你知道民主政体有几种吗？<br>你知道选举都有哪些方式吗，又有哪些方式来实现选举的公平呢？</p><p>这些答案，都在这本书中。  </p><h3 id="寡头统治铁律"><a href="#寡头统治铁律" class="headerlink" title="寡头统治铁律"></a><a href="./GTTZTL.mobi">寡头统治铁律</a></h3><p>政治学通识的推荐读物。</p><p>作者结合了在德国的社会主义工人党工作时的所见所闻与思考，将他的主要思想加以扩展与论证，写成了这本书。</p><p>作者的主要观点，便是在一个组织中，尤其是大规模的组织中，直接民主会越来越难实现。因为随着对于执行间接民主的人的专业性或是某一方面的特殊才能的要求越来越高，普通人将会越来越难以在民主过程中发挥作用。因此，至少在作者眼中看来，现有的民主体系，最后都会不可避免地将权力集中在少数人手中。这，便是作者口中的“寡头统治铁律”。</p><h3 id="发条橙"><a href="#发条橙" class="headerlink" title="发条橙"></a><a href="./FTC.mobi">发条橙</a></h3><p>经典的反乌托邦小说  </p><p>如果要看的话，前半段关于犯罪的描写可以快速跳过，你只需要知道主角很坏就行了。</p><p>主旨基本就是，如果一个人无理由地选择“善”，失去了选择地权力，那他还算一个人吗。</p><h3 id="美丽新世界-amp-重返美丽新世界"><a href="#美丽新世界-amp-重返美丽新世界" class="headerlink" title="美丽新世界&amp;重返美丽新世界"></a><a href="./MLXSJ.mobi">美丽新世界&amp;重返美丽新世界</a></h3><p>经典反乌托邦小说  </p><p>比《1984》更接近于现在的世界。相较于《1984》的使用刑罚与严格的言论控制来实行思想管制，《美丽新世界》使用了更加现代化的方法：药物控制（苏摩）；大量的神奇娱乐（各种神奇的高尔夫与球类运动……）；鼓励多参加群体运动，而不是一个人思考；睡眠时的教育；开放的性。当然，最重要的是出生时就被决定了的等级：从高等阿尔法到低等埃普西隆，以及与之配套的各个阶级分开的教育。同时，诸如莎士比亚的名著等经典作品都成了只有统治阶级才能拥有的禁书。</p><p>所以，你会发现，《1984》中所描绘的集权警察社会早已落伍。《美丽新世界》才是一个对现在的社会更有意义的作品。  </p><p>同时，作者还在《重返美丽新世界》里，以一个作家的身份，去思考了一些社会现实。建议读完《政治学通识》再来看这个，收获会更大。</p><h3 id="围城"><a href="#围城" class="headerlink" title="围城"></a>围城</h3><p>钱钟书经典小说。</p><p>看方渐鸿踩过的坑，自己少踩一点……</p><p><a href="https://chenxizhou233.github.io/2021/12/25/%E4%B8%A5%E8%82%83%E6%96%87%E5%AD%A6/">总集</a></p><h2 id="娱乐文学"><a href="#娱乐文学" class="headerlink" title="娱乐文学"></a>娱乐文学</h2><h3 id="狼与香辛料"><a href="#狼与香辛料" class="headerlink" title="狼与香辛料"></a><a href="./LYXXL.mobi">狼与香辛料</a></h3><p>公路狗粮番，看老夫老妻秀恩爱就行了。</p><p>男主与女主的成长也是一个看点</p><h3 id="未闻花名-我们仍未知道那天所见到的花的名字"><a href="#未闻花名-我们仍未知道那天所见到的花的名字" class="headerlink" title="未闻花名(我们仍未知道那天所见到的花的名字)"></a>未闻花名<a href="https://zh.moegirl.org.cn/%E6%88%91%E4%BB%AC%E4%BB%8D%E6%9C%AA%E7%9F%A5%E9%81%93%E9%82%A3%E5%A4%A9%E6%89%80%E7%9C%8B%E8%A7%81%E7%9A%84%E8%8A%B1%E7%9A%84%E5%90%8D%E5%AD%97">(我们仍未知道那天所见到的花的名字)</a></h3><p>经典催泪轻小说，讲述了主角团中的一位因事故身亡的同年玩伴，面码(本间芽衣子)，在主角团长大后，灵魂又回到人间，因此展开的一系列为了实现她的愿望而发生的主角团之间的故事。</p><h3 id="PsychoPass前传"><a href="#PsychoPass前传" class="headerlink" title="PsychoPass前传"></a>PsychoPass前传</h3><p>著名反乌托邦动画<a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85">PsychoPass</a>的第一部的前传小说。  </p><p>讲述了男主，<a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">监视官</a> <a href="https://zh.moegirl.org.cn/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85/%E8%A7%92%E8%89%B2%E5%88%97%E8%A1%A8"><em>狡啮慎也</em></a> 与他的前任执行官，佐佐山光留，为了追捕一名将人体做为“艺术品”的罪犯而发生的故事。  </p><p>佐佐木在追捕过程中丧命，而这就是是男主从一名监视官降级成执行官的原因。</p><h3 id="末日三问-末日时在做什么-有没有空-可以来拯救吗"><a href="#末日三问-末日时在做什么-有没有空-可以来拯救吗" class="headerlink" title="末日三问(末日时在做什么?有没有空?可以来拯救吗?)"></a>末日三问<a href="https://zh.moegirl.org.cn/%E6%9C%AB%E6%97%A5%E6%97%B6%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%3F%E6%9C%89%E6%B2%A1%E6%9C%89%E7%A9%BA%3F%E5%8F%AF%E4%BB%A5%E6%9D%A5%E6%8B%AF%E6%95%91%E5%90%97%3F">(末日时在做什么?有没有空?可以来拯救吗?)</a></h3><p>异世界日常，治愈（确信）。</p><p>其中“妖怪兵器”为不惧死亡的幼女（雾）的设定还是比较新颖的。</p><h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>经典治愈番的同名小说，不多解释。  </p><h3 id="球状闪电"><a href="#球状闪电" class="headerlink" title="球状闪电"></a>球状闪电</h3><p>刘慈欣经典小说  </p><p>讲述了一名醉心于研究武器的女少校林云在发现“球状闪电”这种武器后发生的一系列故事。</p><p><a href="https://chenxizhou233.github.io/2021/12/25/%E5%A8%B1%E4%B9%90%E6%96%87%E5%AD%A6/#2021-12-25">总集</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCT入门</title>
    <link href="/2021/12/17/LCT%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/17/LCT%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>今天刚刚调出来的LCT板子，以这道题<a href="https://www.luogu.com.cn/problem/P4312">P4312 [COI2009] OTOCI</a>为例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int ll</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-comment">//================================================================</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">3e4</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">0</span>;<br>    T data[maxn];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> !h;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        data[++h] = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">empty</span>())<br>            --h;<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> data[h];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        h = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">namespace</span> Splay<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls son[0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs son[1]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>;<br><span class="hljs-keyword">typedef</span> Node* lpNode;<br>Stack&lt;lpNode&gt; st;<br><span class="hljs-keyword">extern</span> lpNode nil, root;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, weight = <span class="hljs-number">0</span>, tag = <span class="hljs-number">0</span>;<br>    lpNode son[<span class="hljs-number">2</span>] = &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>&#125;, fa = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;fa-&gt;rs == <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;ls, <span class="hljs-keyword">this</span>-&gt;rs);<br>        <span class="hljs-keyword">this</span>-&gt;tag ^= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nRoot</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;fa-&gt;ls == <span class="hljs-keyword">this</span> || <span class="hljs-keyword">this</span>-&gt;fa-&gt;rs == <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;tag)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ls != nil)<br>            <span class="hljs-keyword">this</span>-&gt;ls-&gt;<span class="hljs-built_in">reverse</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;rs != nil)<br>            <span class="hljs-keyword">this</span>-&gt;rs-&gt;<span class="hljs-built_in">reverse</span>();<br>        <span class="hljs-keyword">this</span>-&gt;tag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> fa = <span class="hljs-keyword">this</span>-&gt;fa, gf = fa-&gt;fa;<br>        <span class="hljs-type">int</span> d = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>(), dd = fa-&gt;<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">if</span> (fa-&gt;<span class="hljs-built_in">nRoot</span>())<br>            gf-&gt;son[dd] = <span class="hljs-keyword">this</span>;<br>        fa-&gt;son[d] = <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>]-&gt;fa = fa;<br>        <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>] = fa;<br>        fa-&gt;fa = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">this</span>-&gt;fa = gf;<br>        fa-&gt;<span class="hljs-built_in">update</span>();<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">update</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> y = nil, x = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">while</span> (x != nil)<br>        &#123;<br>            x-&gt;<span class="hljs-built_in">splay</span>();<br>            x-&gt;rs = y;<br>            x-&gt;<span class="hljs-built_in">update</span>();<br>            x = (y = x)-&gt;fa;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeRoot</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">access</span>();<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">splay</span>();<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">reverse</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;val = <span class="hljs-keyword">this</span>-&gt;ls-&gt;val +<br>                    <span class="hljs-keyword">this</span>-&gt;rs-&gt;val + <span class="hljs-keyword">this</span>-&gt;weight;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        st.<span class="hljs-built_in">clear</span>();<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>);<br>        lpNode y = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">while</span> (y-&gt;<span class="hljs-built_in">nRoot</span>())<br>        &#123;<br>            y = y-&gt;fa;<br>            st.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            st.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">pushDown</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">nRoot</span>(); <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">rotate</span>())<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;fa-&gt;<span class="hljs-built_in">nRoot</span>())<br>                (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>() == <span class="hljs-keyword">this</span>-&gt;fa-&gt;<span class="hljs-built_in">get</span>() ? <span class="hljs-keyword">this</span>-&gt;fa : <span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">rotate</span>();<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">update</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(lpNode y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">makeRoot</span>();<br>        y-&gt;<span class="hljs-built_in">access</span>();<br>        y-&gt;<span class="hljs-built_in">splay</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(lpNode y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">split</span>(y);<br>        <span class="hljs-keyword">this</span>-&gt;fa = y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(lpNode y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">split</span>(y);<br>        <span class="hljs-keyword">this</span>-&gt;fa = y-&gt;ls = nil;<br>    &#125;<br>    <span class="hljs-function">lpNode <span class="hljs-title">findRoot</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> tmp = <span class="hljs-keyword">this</span>;<br>        tmp-&gt;<span class="hljs-built_in">access</span>();<br>        tmp-&gt;<span class="hljs-built_in">splay</span>();<br>        <span class="hljs-keyword">while</span> (tmp-&gt;ls != nil)<br>            tmp = tmp-&gt;ls, tmp-&gt;<span class="hljs-built_in">pushDown</span>();<br>        tmp-&gt;<span class="hljs-built_in">splay</span>();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getW</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">this</span>-&gt;weight);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getSum</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">this</span>-&gt;val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;fa = <span class="hljs-keyword">this</span>-&gt;ls = <span class="hljs-keyword">this</span>-&gt;rs = nil;<br>    &#125;<br>&#125; pool[maxn];<br>lpNode nil = <span class="hljs-keyword">new</span> Node;<br>lpNode root = nil;<br>&#125;<br><br><span class="hljs-type">int</span> canselSync =   (std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),<br>                    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),<br>                    std::cout.<span class="hljs-built_in">tie</span>(), <span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n, m;<br>std::string s;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//============================================</span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> FastIO;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Splay;<br>    nil-&gt;<span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n, m; <span class="hljs-type">char</span> s[<span class="hljs-number">15</span>]; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> tmp = pool + i;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, tmp-&gt;<span class="hljs-built_in">getW</span>());<br>        tmp-&gt;<span class="hljs-built_in">init</span>();<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;m);<br>    lpNode u, v;<br>    <span class="hljs-type">int</span> uu, vv;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%lld%lld&quot;</span>, s + <span class="hljs-number">1</span>, &amp;uu, &amp;vv);<br>        u = pool + uu, v = pool + vv;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (u-&gt;<span class="hljs-built_in">findRoot</span>() != v-&gt;<span class="hljs-built_in">findRoot</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> u-&gt;<span class="hljs-built_in">split</span>(v), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, *(v-&gt;<span class="hljs-built_in">getSum</span>()));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;p&#x27;</span>) u-&gt;<span class="hljs-built_in">splay</span>(), *(u-&gt;<span class="hljs-built_in">getW</span>()) = vv, u-&gt;<span class="hljs-built_in">update</span>();<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (u-&gt;<span class="hljs-built_in">findRoot</span>() == v-&gt;<span class="hljs-built_in">findRoot</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>), u-&gt;<span class="hljs-built_in">link</span>(v);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//============================================</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针版Splay</title>
    <link href="/2021/12/12/%E6%8C%87%E9%92%88Slpay/"/>
    <url>/2021/12/12/%E6%8C%87%E9%92%88Slpay/</url>
    
    <content type="html"><![CDATA[<p>调了好久的指针版Splay，记录一下，方便今后使用</p><p><a href="https://www.luogu.com.cn/problem/P3369">P3369 普通平衡树</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int ll</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">namespace</span> Splay<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls son[0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs son[1]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>;<br><span class="hljs-keyword">typedef</span> Node *lpNode;<br><span class="hljs-keyword">extern</span> lpNode nil;<br><span class="hljs-keyword">extern</span> lpNode root;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;<br>    lpNode son[<span class="hljs-number">2</span>] = &#123;nil, nil&#125;, fa = nil;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-keyword">this</span>-&gt;ls-&gt;size + <span class="hljs-keyword">this</span>-&gt;rs-&gt;size + <span class="hljs-keyword">this</span>-&gt;cnt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;fa-&gt;rs == <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> fa = <span class="hljs-keyword">this</span>-&gt;fa, gf = fa-&gt;fa;<br>        <span class="hljs-type">int</span> d = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>(), dd = fa-&gt;<span class="hljs-built_in">get</span>();<br>        fa-&gt;son[d] = <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>]-&gt;fa = fa;<br>        <span class="hljs-keyword">this</span>-&gt;son[d ^ <span class="hljs-number">1</span>] = fa;<br>        fa-&gt;fa = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">this</span>-&gt;fa = gf;<br>        <span class="hljs-keyword">if</span> (gf != nil)<br>            gf-&gt;son[dd] = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pushUp</span>();<br>        fa-&gt;<span class="hljs-built_in">pushUp</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (lpNode fa; (fa = <span class="hljs-keyword">this</span>-&gt;fa) != nil; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">rotate</span>())<br>            <span class="hljs-keyword">if</span> (fa-&gt;fa != nil)<br>                (fa-&gt;<span class="hljs-built_in">get</span>() == <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>() ? fa : <span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">rotate</span>();<br>        root = <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125; pool[maxn];<br>lpNode nil = <span class="hljs-keyword">new</span> Node;<br>lpNode root = nil;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = root;<br>    lpNode fa = nil;<br>    <span class="hljs-keyword">while</span> (x != nil &amp;&amp; x-&gt;val != val)<br>    &#123;<br>        fa = x;<br>        x = x-&gt;son[x-&gt;val &lt; val];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x != nil)<br>        ++x-&gt;cnt;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        x = pool + (++cnt);<br>        x-&gt;val = val;<br>        x-&gt;fa = fa;<br>        <span class="hljs-keyword">if</span> (fa != nil)<br>            fa-&gt;son[fa-&gt;val &lt; val] = x;<br>        x-&gt;cnt = x-&gt;size = <span class="hljs-number">1</span>;<br>        x-&gt;ls = x-&gt;rs = nil;<br>    &#125;<br>    x-&gt;<span class="hljs-built_in">splay</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRank</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = root;<br>    <span class="hljs-type">int</span> rk = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x != nil)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x-&gt;val &gt; val)<br>            x = x-&gt;ls;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x-&gt;val == val)<br>        &#123;<br>            rk += x-&gt;ls-&gt;size;<br>            <span class="hljs-keyword">return</span> x-&gt;<span class="hljs-built_in">splay</span>(), rk + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            rk += x-&gt;ls-&gt;size + x-&gt;cnt, x = x-&gt;rs;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getVal</span><span class="hljs-params">(<span class="hljs-type">int</span> rk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = root;<br>    <span class="hljs-keyword">while</span> (x != nil)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x-&gt;ls-&gt;size &gt;= rk)<br>            x = x-&gt;ls;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rk &lt;= x-&gt;ls-&gt;size + x-&gt;cnt)<br>        &#123;<br>            x-&gt;<span class="hljs-built_in">splay</span>();<br>            <span class="hljs-keyword">return</span> x-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            rk -= x-&gt;ls-&gt;size + x-&gt;cnt, x = x-&gt;rs;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getPre</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pre;<br>    <span class="hljs-keyword">auto</span> x = root;<br>    <span class="hljs-keyword">while</span> (x != nil)<br>        <span class="hljs-keyword">if</span> (x-&gt;val &lt; val)<br>            pre = x-&gt;val, x = x-&gt;rs;<br>        <span class="hljs-keyword">else</span><br>            x = x-&gt;ls;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getNxt</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> nxt;<br>    <span class="hljs-keyword">auto</span> x = root;<br>    <span class="hljs-keyword">while</span> (x != nil)<br>        <span class="hljs-keyword">if</span> (x-&gt;val &gt; val)<br>            nxt = x-&gt;val, x = x-&gt;ls;<br>        <span class="hljs-keyword">else</span> x = x-&gt;rs;<br>    <span class="hljs-keyword">return</span> nxt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">getRank</span>(val);<br>    <span class="hljs-keyword">if</span> (--(root-&gt;cnt))<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;ls == nil &amp;&amp; root-&gt;rs == nil)<br>        root = nil;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;ls == nil)<br>        root = root-&gt;rs, root-&gt;fa = nil, root-&gt;<span class="hljs-built_in">pushUp</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;rs == nil)<br>        root = root-&gt;ls, root-&gt;fa = nil, root-&gt;<span class="hljs-built_in">pushUp</span>();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> pre = root-&gt;ls, x = root;<br>        <span class="hljs-keyword">while</span> (pre-&gt;rs != nil)<br>            pre = pre-&gt;rs;<br>        pre-&gt;<span class="hljs-built_in">splay</span>();<br>        root-&gt;rs = x-&gt;rs;<br>        x-&gt;rs-&gt;fa = root;<br>        root-&gt;<span class="hljs-built_in">pushUp</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    nil-&gt;fa = nil-&gt;ls = nil-&gt;rs = nil;<br>    nil-&gt;cnt = nil-&gt;val = nil-&gt;size = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021115模拟赛总结</title>
    <link href="/2021/11/15/2021115%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/11/15/2021115%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定字符串 S , 求至多能将其分成几块，使得分割后的字符串为回文字符串。<br>如：  </p><ol><li>“abcba”-&gt; “a,b,c,b,a”,5块</li><li>“bonbcbo”-&gt; “bo,nbc,bo”三块  </li><li>“abcdefg”-&gt; “abcdefg”一块  </li></ol><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>通过观察分割的性质可得，贪心分割一定是最优策略，因此可直接贪心。  </p><p>这里主要提的是如何判断首尾的两个字符串是否回文。</p><p>我的第一个 60pts 的想法便是使用 <code>string</code> 硬判，但我们发现， <code>string</code> 的判断是 $\mathcal{O}(n)$ 的，因此我们需要考虑一个更优秀的做法。</p><p>因此，我们可以选择一个更优秀的 $\mathcal{O}(1)$ 方法： <strong>字符串哈希</strong> 。  </p><p>这样，我们就能做到 $\mathcal{O}(1)$ 判断了。  </p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点 $(x_i,y_i)$ ,求有多少个点对  $(a,b),(c,d)$ 满足曼哈顿距离小于 $d$ 。</p><h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>首先，我们引入一个新概念 : <a href="https://chenxizhou233.github.io">切比雪夫距离</a> 。<br>它的定义是两点间纵坐标差值的绝对值与横坐标差值的绝对值的最大值。</p><p>那么这两个看起来互不相干的定义有什么联系吗？<br>其实，在对坐标轴进行一些变换后，二者在某种意义上便是等价的了。</p><p>首先，给出它们转换的方法：</p><ol><li>曼哈顿距离-&gt;切比雪夫距离 对所有原坐标系中的点 $(x,y)$ ,令其在新坐标系得坐标为 $(x+y,x-y)$ ,新坐标系中的切比雪夫距离便是原坐标系的曼哈顿距离。</li><li>切比雪夫距离-&gt;曼哈顿距离 对所有原坐标系中的点 $(x,y)$ ,令其在新坐标系得坐标为 $(\frac{x+y}{2},\frac{x-y}{2})$ ,新坐标系中的曼哈顿距离便是原坐标系的切比雪夫距离。</li></ol><p>那么，在这道题中，这个转化有什么用呢？</p><p>通过观察我们可以发现，距远点曼哈顿距离小于等于 $1$ 的点围成的图形是一个旋转的正方形（菱形）。<br>而距原点切比雪夫距离小于 $1$的点所构成的图形则是一个正着的正方形  </p><p>所以首先，我们可以将每个点按 $y$ 轴坐标排序（ $x$ 轴也行）。</p><p>然后我们会发现，对于原坐标系中与点 $(x,y)$ 曼哈顿距离小于等于 $d$ 的点，都会在左上角坐标为 $(x+d,y-d)$ ，边长为 $2d$ 的正方形中。</p><p>所以我们呢就可以使用类似于单调队列的思想，使用树状数组动态维护一个边长为 $2d$ 的正方形区域。</p><p>代码中会再做讲解。  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//Copyright (c) 2019 by xiao_mmQF. All Rights Reserved.</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), d = <span class="hljs-built_in">read</span>(), l = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (reg <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-comment">//a为点的数组</span><br>        a[i].x = x + y, a[i].y = x - y;<br>        a[i].x += <span class="hljs-number">2</span> * l + <span class="hljs-number">1</span>, a[i].y += <span class="hljs-number">2</span> * l + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//有负坐标，因此要加一个大数。</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<span class="hljs-comment">//按x坐标排序</span><br>    <span class="hljs-keyword">for</span> (reg <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">abs</span>(a[i].y - a[j].y) &gt;= d)<br>        &#123;<br>            <span class="hljs-comment">//当前后两个点的距离大于 2d 了，说明已经过了统计的区间，因此从树状数组中删去</span><br>            <span class="hljs-built_in">add</span>(a[j].x, <span class="hljs-number">-1</span>), ++j;<br>        &#125;<br>        <span class="hljs-comment">//将y坐标在统计区间内的点，在其对应的x轴上的区间进行修改，然后统计</span><br>        ans += <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">min</span>(MAX, a[i].x + d - <span class="hljs-number">1</span>)) - <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, a[i].x - d));<br>        <span class="hljs-built_in">add</span>(a[i].x, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">Print</span>((n * n - n) / <span class="hljs-number">2</span> - ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-amp-D"><a href="#C-amp-D" class="headerlink" title="C&amp;D"></a>C&amp;D</h2><p>一个神奇的树上dp与打爆搜，没改出来 QAQ。</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流-最大流</title>
    <link href="/2021/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    <url>/2021/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="网络流-最大流"><a href="#网络流-最大流" class="headerlink" title="网络流-最大流"></a>网络流-最大流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><em>什么是网络？</em></p></blockquote><p>一张有向图，且一般都会有一个源点与一个汇点  </p><blockquote><p><em>什么是“流”？</em>  </p></blockquote><p>“流” 就是在网络流问题中，给边的一个新属性：“流量”。代表这条边能承载的最大流量。  </p><blockquote><p><em>它有什么性质？</em>  </p></blockquote><p>在网络流中，每个节点并不储存流量，流量只是从中经过。因此，类似于基尔霍夫电流定率，对于每个点，我们可以得到 “进入这个点的流量=从这个点发出的流量”这个小性质。  </p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在网络流中，最常见的是这样一类问题：求从原点出发，到汇点的最大流量和。</p><p>对于这种问题，我们最常用的是 <em>Ford-Fulkerson</em> 算法及其优化。  </p><h3 id="朴素FF算法"><a href="#朴素FF算法" class="headerlink" title="朴素FF算法"></a>朴素FF算法</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>FF算法的核心就是不断地 “寻找增广路” ，直到无法再扩展了为止。</p><p>何为增广路？</p><p>其实就是一条源点到汇点的路径，路径上的每条边的 “剩余容量” 都不为 0。</p><p>但我们发现，如果在原图上贪心地进行这个过程，找到的“最大流”很可能并不是真正的最大流。<br>如这种情况中</p><pre><code class=" mermaid">graph LR    1--&gt;|1|2 &amp; 3--&gt;|1|4      2--&gt;|1|3</code></pre><p>若按 1-&gt;2-&gt;3-&gt;4 的顺序进行增广，求出的对大刘就应是 1 而不是 1-&gt;2-&gt;4,1-&gt;3-&gt;4 的 2。</p><p>为了解决这个问题，我们引入反向边，这样原图就变为了  </p><pre><code class=" mermaid">graph LR     1--&gt;|1|2 &amp; 3--&gt;|1|4     2--&gt;|0|1    3--&gt;|0|1    3--&gt;|0|2    2--&gt;|1|3    4--&gt;|0|2    4--&gt;|0|3</code></pre><p>这时，我们再次寻找增广路时，在减小边权时，要同时为反边加上相同的权值。</p><p>这样处理后，我们这次在找到 1-&gt;2-&gt;3-&gt;4 这条增广路后，还有另一条增广路路 1-&gt;3-&gt;2-&gt;4 可以走。因此最大流为 2。</p><p>我们发现，3-&gt;4 与 4-&gt;3 这两条边分别被走了一次，从流量的角度来看，其实走的算 “无用功” ，两条边的流量相互抵消了。</p><p>因此，真正走的路径，其实是 1-&gt;3-&gt;4与1-&gt;2-&gt;4。</p><p>所以这次处理的实际效果，其实就是相当于增加了“反悔”机制：让之前选择的流量可以“撤回”。从而保证了在找不到增广路时，也就是连反悔都没有机会是，所找到的最大流一定是真正的最大流。  </p><p>因此，我们便可以根据朴素的思想，写出网络流中的第一份代码了  </p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>先来规定一下之后用到的图的存储方式及函数  </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> G<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>;<br><span class="hljs-keyword">typedef</span> Edge* pointer;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//因为要建反边，因此两条边的编号一定相邻。有没有什么快速获取邻边的方法呢？</span><br><span class="hljs-comment">//当然是异或，不过这样一定要将cnt初始化为 -1.下面的加边操作中也有体现。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> to, w, c;<span class="hljs-comment">//终点，容量，费用  </span><br>    pointer nxt, rev;<span class="hljs-comment">//反向边</span><br>&#125;E[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> tmp = E + (++cnt);<br>    tmp-&gt;to  = v;<br>    tmp-&gt;w   = w;<br>    tmp-&gt;c   = c;<br>    tmp-&gt;rev = E + (cnt ^ <span class="hljs-number">1</span>);<br>    tmp-&gt;nxt = head[u];<br>    head[u]  = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">add</span>(u, v, w, c), <span class="hljs-built_in">add</span>(v, u, <span class="hljs-number">0</span>, -c);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>以下代码是 DFS 实现的 FF算法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, s, t;<br><span class="hljs-type">int</span> vis[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p  = s,<span class="hljs-type">int</span> flow = INF)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p==t)<br>        <span class="hljs-keyword">return</span> flow;<br>    vis[p] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = head[p];e;e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span>(e-&gt;w&amp;&amp;!vis[e-&gt;to]&amp;&amp;(c=<span class="hljs-built_in">dfs</span>(e-&gt;to,std::<span class="hljs-built_in">min</span>(flow,e-&gt;w))!=<span class="hljs-number">-1</span>))<br>        &#123;<br>            e-&gt;w -= c;<br>            e-&gt;rev-&gt;w += c;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">FF</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, c;<br>    <span class="hljs-keyword">while</span> ((c = <span class="hljs-built_in">dfs</span>()) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        std::<span class="hljs-built_in">fill</span>(vis,vis+n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);<br>        ans += c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>简单地说，EK算法就是BFS实现的FF算法，我们直接看代码。  </p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, s, t;<br><span class="hljs-type">int</span> flow[maxn];<br>Edge* las[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">fill</span>(las, las+n+<span class="hljs-number">2</span>, <span class="hljs-literal">nullptr</span>);<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(p == t)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = head[p];e;e = e-&gt;nxt)<br>            <span class="hljs-keyword">if</span>(e-&gt;w&gt;<span class="hljs-number">0</span>&amp;&amp;las[e-&gt;to]==<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                las[e-&gt;to] = e;<br>                flow[e-&gt;to] = std::<span class="hljs-built_in">min</span>(flow[p],e-&gt;w);<br>                Q.<span class="hljs-built_in">push</span>(e-&gt;to);<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> las[t] != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> maxflow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>())<br>    &#123;<br>        maxflow += flow[t];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t; i != s; i = edges[last[i] ^ <span class="hljs-number">1</span>].to) <span class="hljs-comment">// 从汇点原路返回更新残余容量</span><br>        &#123;<br>            edges[last[i]].w -= flow[t];<br>            edges[last[i] ^ <span class="hljs-number">1</span>].w += flow[t];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxflow;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Dinic算法还是 FF/EK 算法的优化。</p><p>它选择了先用 BFS 分层，再用 DFS 寻找增广路的方法。</p><p>为什么分层后更优呢？可以类比一下水流，水往低处流嘛。而在网络中也是同理。在向上层流去的时候并不能为结果做出贡献，因此分层后可以保证不走回头路。</p><p>且每次 DFS 前都需分层，因为可能有的边流量变为0，无法继续增广。</p><p>我们还可以使用多路增广节省很多花在重复路线上的时间：在某点DFS找到一条增广路后，如果还剩下多余的流量未用，继续在该点DFS尝试找到更多增广路。</p><p>同时，还可以使用“当前弧优化”。其实就是因为在一轮多路增广中，一条边不会被重复经过，因此可记录当前边在链表中的位置，可以节省时间。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> s,t,n,m;<br><span class="hljs-type">int</span> lv[maxn]; <span class="hljs-comment">//分层</span><br>pointer cur[maxn]; <span class="hljs-comment">//当前弧优化</span><br><br><span class="hljs-keyword">namespace</span> Dinic<br>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> G;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> flow)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">copy</span>(head, head+maxn, cur);<br>    std::<span class="hljs-built_in">fill</span>(lv,lv+maxn,<span class="hljs-number">-1</span>); <span class="hljs-comment">//每一次都要初始化层数，重新求</span><br>    lv[s] = <span class="hljs-number">0</span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = head[p] ;e ; e = e-&gt;nxt)<br>            <span class="hljs-keyword">if</span>(e-&gt;w &gt; <span class="hljs-number">0</span> &amp;&amp; lv[e-&gt;to] != <span class="hljs-number">-1</span>)<br>                lv[e-&gt;to] = lv[p] + <span class="hljs-number">1</span>, Q.<span class="hljs-built_in">push</span>(e-&gt;to);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lv[t] != <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p = s,<span class="hljs-type">int</span> flow = INF)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p==t)<br>        <span class="hljs-keyword">return</span> flow;<br>    <span class="hljs-type">int</span> rmn = flow;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = cur[p];e &amp;&amp; rmn; e = e-&gt;nxt)<br>    &#123;<br>        cur[p] = e;<br>        <span class="hljs-keyword">if</span>(e-&gt;w &gt;<span class="hljs-number">0</span> &amp;&amp; lv[e-&gt;to] == lv[p] + <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> c = <span class="hljs-built_in">dfs</span>(e-&gt;to ,std::<span class="hljs-built_in">min</span>(flow, rmn));<br>            rmn -= c;<br>            e-&gt;w -= c;<br>            e-&gt;rev-&gt;w += c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flow - rmn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<br>        ans += <span class="hljs-built_in">dfs</span>();<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>我们可以发现，这个求的还是最大流，只是增加了费用的限制。</p><p>因此我们可以直接将EK算法中的BFS换成SPFA，然后跑最大流即可。</p><p>为什么不用dij呢？因为它不能处理负权边。</p><p>当然你也可以整个势能法，重新定义一下边权再 Dijkstra 。</p><p>可是这也相当于跑了个 Bellman-Ford 算法,不如直接 SPFA 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说到底，最大流只是网络流问题的一种。</p><p>大部分网络流的题并不是十分的板子，需要多做，多积累。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp小结-数位dp</title>
    <link href="/2021/11/08/dp%E5%B0%8F%E7%BB%93-%E6%95%B0%E4%BD%8Ddp/"/>
    <url>/2021/11/08/dp%E5%B0%8F%E7%BB%93-%E6%95%B0%E4%BD%8Ddp/</url>
    
    <content type="html"><![CDATA[<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在OI中，我们可能会遇到这样一类问题：</p><blockquote><p>求给定数据范围 $L,R,(1\leq L,R\leq 10^{18})$ 满足某种性质的数的个数。  </p></blockquote><p>对于这样一类问题，我们发现过大的数据范围是无法让我们使用普通的枚举去解决的。那我们该怎么办呢？  </p><p>这时，就该请出我们今天的主角，数位dp了 (其实叫数位递推更合适) ？</p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><blockquote><p>给定范围 $L,R,(1\leq L,R\leq 10^{18})$ ,求数字 $0\sim 9$ 各出现了多少次  </p></blockquote><p>发现我们维护的数据具有区间可见性，因此问题可转化为求 $[1,L-1]$ 中的各数字个数与 $[1,R]$ 中的各数字个数。</p><p>在递推过程中，我们发现，若递推上界为 $234567$ ，则 $21——$ 与 $22——$ 对应的答案个数是一样的，因此这些状态便可合并，复杂度因此降低。  </p><p>那如果递推到了 $23——$ 呢？，我们可以发现，此时的答案与 $21——$ 时不同。为了解决这种边界情况，我们选择使用一个额外的变量 $limit$ 来表示有没有取到边界情况的状态。  </p><p>同时，我们还需考虑前导零的问题。我们同样可以使用 $lead$ 来记录现在是不是取了前导零的状态。  </p><p>了解了这些，我们呢就可以看一看第一道数位dp的代码了。 </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int ll</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> A[<span class="hljs-number">22</span>],cnt,digit;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x)<br>        A[cnt++] = x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>;<br>    std::<span class="hljs-built_in">reverse</span>(A,A+cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>    std::<span class="hljs-built_in">fill</span>(A,A+<span class="hljs-number">23</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">divide</span>(x);<br>&#125;<br><span class="hljs-comment">//cntd所存为dp所求答案</span><br><span class="hljs-function">ll <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> cntd,<span class="hljs-type">bool</span> limit,<span class="hljs-type">bool</span> lead)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(pos==cnt)<br>        <span class="hljs-keyword">return</span> cntd;<br>    <span class="hljs-type">int</span> tmp = dp[pos][cntd][limit][lead];<br>    <span class="hljs-keyword">if</span>(tmp!=<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> tmp;<br>    <span class="hljs-type">int</span> lim = limit ? A[pos] : <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;v&lt;=lim;++v)<br>    <span class="hljs-keyword">if</span>(lead&amp;&amp;v==<span class="hljs-number">0</span>)<br>        ans+=<span class="hljs-built_in">dp</span>(pos+<span class="hljs-number">1</span>,cntd,limit&amp;&amp;v==A[pos],lead);<br>    <span class="hljs-keyword">else</span> <br>        ans+=<span class="hljs-built_in">dp</span>(pos+<span class="hljs-number">1</span>,cntd+(v==digit),limit&amp;&amp;A[pos]==v,<span class="hljs-literal">false</span>);<br>    dp[pos][cntd][limit][lead] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>(x);<br>    <span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    std::cin&gt;&gt;l&gt;&gt;r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">9</span>;++i)<br>    &#123;<br>        digit = i;<br>        <span class="hljs-type">int</span> ll = <span class="hljs-built_in">f</span>(l - <span class="hljs-number">1</span>), rr = <span class="hljs-built_in">f</span>(r);<br>        std::cout &lt;&lt; rr - ll &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><blockquote><p>求给定范围中，没有 ‘4’ 和 ‘62’ 的数。  </p></blockquote><p>我们可以发现，我们这次不关注是否有前导零，而是关注上一位是否为 ‘6’。</p><p>因此我们可以对上面的变量含义稍作修改： 令 $lead$ 表示上一位数是否为 ‘6’ .</p><p>下面是dp函数  </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> last, <span class="hljs-type">bool</span> limit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pos == cnt)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">if</span> (dp[pos][last][limit] != <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> dp[pos][last][limit];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt;= (limit ? A[pos] : <span class="hljs-number">9</span>); ++v) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-number">6</span> &amp;&amp; v == <span class="hljs-number">2</span> || v == <span class="hljs-number">4</span>) <br>            <span class="hljs-keyword">continue</span>;<br>        ans += <span class="hljs-built_in">dfs</span>(pos + <span class="hljs-number">1</span>, v, limit &amp;&amp; v == A[pos]);<br>    &#125;<br>    dp[pos][last][limit] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp小结-简单模型</title>
    <link href="/2021/11/07/dp/"/>
    <url>/2021/11/07/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="简单的模型"><a href="#简单的模型" class="headerlink" title="简单的模型"></a>简单的模型</h2><h3 id="最长上升子序列，LIS-Longest-Increasing-Subsequence"><a href="#最长上升子序列，LIS-Longest-Increasing-Subsequence" class="headerlink" title="最长上升子序列，LIS(Longest Increasing Subsequence)"></a>最长上升子序列，LIS(Longest Increasing Subsequence)</h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p>很容易考虑到，我们可以设 $dp_i$ 为以 $a_i$ 结尾的LIS长度。  </p><p>每次转移朴素的枚举转移 <script type="math/tex">dp_i=\max \limits_{j<i,a_j<a_i} \{dp_j +1\}</script> 。  </p><p>这样枚举的复杂度为 $\mathcal{O(n^2)}$ 。</p><p>观察朴素方法，我们发现时间复杂度的瓶颈在于寻找前 $i$ 个数中，小于 $a_i$ 的数的个数。<br>那么我们可以怎么优化呢？</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>进一步观察，在每次更新时，选择值更小的 $a_j$ 一定更优。<br>感性理解一下，对于两个长度一定的LIS，尾部的元素更小的那个，可选择的元素一定多于尾部元素更大的那个，就更有可能增长长度。</p><p>因此，我们可以修改一下 $dp$ 数组的定义 ： 设 $dp_{len}$ 为长度为 $len$ 的LIS的结尾元素的最小值。</p><p>我们根据之前发现的规律可知， $dp$ 应是单调的。</p><blockquote><p>证明： 若存在 $dp_i&gt;dp_j,(i&lt;j)$ ,则必存在一种构造，使 $dp_j$ 去掉 $(j-i)$ 个元素后，长度为 $i$。则 $dp_j$ 的结尾最小值就会被重新更新。  </p></blockquote><p>因此，我们可以考虑二分。</p><p>设当前的LIS最大长度为 $len$ 。</p><p>对于待插入的数 $a<em>i$ ，若 $a_i&gt;dp</em>{len}$ 则直接将其插入这个子序列中。</p><p>否则，寻找第一个 $a_i&gt;dp_j,j\in[1,len)$ 的位置，更新 $dp_j$ 。</p><p>这样，最后的 $len$ 的长度，便是我们所求的答案。</p><p>本做法复杂度为 $\mathcal{O(n\log n)}$</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//变量名含义同上</span><br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=a;++i)<br>&#123;   <br>    <span class="hljs-keyword">if</span>(a[i]&gt;dp[len])<br>        dp[++len] = a[i];<br>    <span class="hljs-keyword">else</span> <br>        *<span class="hljs-built_in">lower_bound</span>(dp+<span class="hljs-number">1</span>,dp+<span class="hljs-number">1</span>+len,a[i]) = a[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="最长公共子序列-LCS-Longest-Common-Subsequnce"><a href="#最长公共子序列-LCS-Longest-Common-Subsequnce" class="headerlink" title="最长公共子序列(LCS, Longest Common Subsequnce)"></a>最长公共子序列(LCS, Longest Common Subsequnce)</h3><h4 id="朴素方法-1"><a href="#朴素方法-1" class="headerlink" title="朴素方法"></a>朴素方法</h4><h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>设 $dp_{i,j}$ 为递推到第一个字符串第 $i$ 位，第二个字符串第 $j$ 位时的LCS长度。<br>可得  </p><script type="math/tex; mode=display">dp_{i,j}=\left\{\begin{aligned}&dp_{i-1,j-1}+1&if {s1}_i={s2}_{j} \\&\max \{dp_{i,j-1},dp_{i-1,j}\}&otherwise\end{aligned}\right.</script><p>之后根据这个递推式，递推便可求出结果。  </p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::string s1,s2;<br><span class="hljs-keyword">while</span>(std::cin&gt;&gt;s1&gt;&gt;s2)<br>&#123;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-type">int</span> len1 = s1.<span class="hljs-built_in">size</span>(),len2 = s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=len1;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=len2;++j)<br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>]==s2[j<span class="hljs-number">-1</span>])<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = std::<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>    std::cout&lt;&lt;dp[len1][len2]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h4><p>当元素为排列(无重复元素)时，可考虑将LCS转化为LIS。</p><p>记 $pos$ 为 $s1$ 的每个位置上的字符在 $s2$ 的对应位置。</p><p>考虑LCS中每个字符的性质。</p><p>对于s1的每一个字串，当且仅当它的 $pos$ 值单调增加时，才有可能成为LCS。</p><p>因此，本问题就转化为了LIS问题，有 $\mathcal{O(nlogn)}$ 做法。</p><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>背包问题是这样一类问题。<br>给定 $n$ 个物品，第 $i$ 个物品有价值 $val_i$与重量 $weight_i$ 。</p><blockquote><p>一般的描述为物品价值为 $w$ ,重量为 $v$ 。</p></blockquote><p>求在给定的限制条件下，能取到的最大值是多少。 </p><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>限制条件为每个物品只能取一个。</p><p>考虑dp的状态设计：</p><p>这里直接给出使用滚动数组优化后的定义。</p><p>设 $dp_i$ 为重量为 $i$ 时的最大价值。</p><p>转移为 $dp<em>i=\max \limits</em>{j\in[1,n],v<em>i\leq i}{dp</em>{i-v_j}+w_j}$<br>同时，需倒序枚举 $i$ 。 </p><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>限制条件为每个物品可以取无穷多个</p><p>dp的式子与01背包完全相同。但要正序枚举。</p><p>倒序与正序有什么区别呢？ </p><p>在正序枚举时，每个物品都可以重复贡献价值，符合限制条件。</p><p>而在倒序枚举时，每个物品都只为“体积到达i” 贡献了一次，而这也正符合01背包的定义。</p><h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>限制条件为第 $i$ 个物品可取 $c_i$ 个。</p><p>对于这种情况，我们有两种解决方案  </p><h5 id="二进制分组"><a href="#二进制分组" class="headerlink" title="二进制分组"></a>二进制分组</h5><p>考虑将其转化为01背包。</p><p>对于每一个有 $k$ 个的物品。<br>都可看作是由多个 $2^i$个相同的物品组成的物品组成的。<br>如当 $k$ 为10时，就可以看做是 $1,2,4,3$ 组成的。<br>为什么这样一定可以拼出来呢？<br>情况1：对于 $k\in[1,2^{\lfloor\log k\rfloor}-1]$ ,显然可以。<br>情况2：对于 $k\in[2^{\lfloor\log k\rfloor},k]$,我们一定可以使用分剩下的数 $res$ 加上情况1中的数拼出来。<br>因此这种分割是合法的。<br>因为会分出 $\log n$ 个物品，因此复杂度为 $\mathcal{O(mn\log n)}$</p><p>同时这个背包也要倒序枚举。</p><h5 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h5><p>观察原始dp式子：</p><script type="math/tex; mode=display">dp_j=\max \limits_{1\leq cnt\leq c_j}\{dp_{j-cnt\times v_j}+cnt\times w_j\}</script><p>可以发现， $\forall j\equiv b\pmod {v_i},b\in[1,v_i)$,它们的dp状态是有重叠部分的，因此我们可以按 $b$ 进行分组。  </p><p><del>(开始搬蓝书了)</del></p><p>我们可以将原来的”倒序枚举j”，改为对每个余数 $b$ ,倒序枚举 $p=\lfloor(V-b)/v_i\rfloor \sim 0$,对应的状态就是 $j=b+p\times v_i$ 。</p><p>故能转移到 $j=b+p\times v_i$ 的决策集就是 ${b+k\times v_i|p-c_i\leq k\leq p-1}$ 。</p><p>新的转移方程为 </p><script type="math/tex; mode=display">dp_{b+p\times v_i=\max \limits_{p-c_i\leq p-1}\{dp_{b+k\times v_i}+(p-k)\times w_i\}}</script><p>按照单调队列优化的经典转移，我们将外层变量 $i,b$ 看作定值，当 $p$ 减小时， $k$ 的上下界均会减小。<br>此时等号右边的式子还是可以分为两部分：仅包含 $p$ 的 $p\times w<em>i$ 与仅包含 $k$ 的 $dp</em>{b+k\times v_i}-k\times w_i$ 。</p><p>综上，我们可以维护一个决策点 $k$ 单调递减，数值 $dp_{b+k\times v_i}-k\times w_i$ 单调递减的队列。</p><p>对于每个 $p$, 我们执行以下操作：</p><ol><li>检查队头合法性，把大于 $p-1$ 的决策点出队。</li><li>取队头为最优决策，更新 $dp_{d+p\times v_i}$</li><li>将新决策 $k = p-c_i-1 $ 入队，并检查单调性，排除无用决策。</li></ol><p>整个算法的时间复杂度为 $\mathcal{O(NM)}$ 。</p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[b+k*v[i]]-k*w[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    std::<span class="hljs-built_in">fill</span>(dp,dp+maxn+<span class="hljs-number">1</span>,<span class="hljs-number">0xcfcfcfcf</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        std::cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;c[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;b&lt;v[i];++b)<br>        &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> maxp = (m-d)/v[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = maxp<span class="hljs-number">-1</span>;k &gt;= std::<span class="hljs-built_in">max</span>(maxp-c[i],<span class="hljs-number">0</span>);--k)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;<span class="hljs-built_in">calc</span>(i,b,q[r])&lt;=<span class="hljs-built_in">calc</span>(i,b,k))--r;<br>                q[++r] = k;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = maxp;p&gt;=<span class="hljs-number">0</span>;--p)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;p<span class="hljs-number">-1</span>)++l;<br>                <span class="hljs-keyword">if</span>(l&lt;=r)<br>                    f[b+p*v[i]] = std::<span class="hljs-built_in">max</span>(f[b+p*v[i]],<span class="hljs-built_in">calc</span>(i,b,q[l])+p*w[i]);<br>                <span class="hljs-keyword">if</span>(p-c[i]<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;<br>                        <span class="hljs-built_in">calc</span>(i,b,q[r])&lt;=<span class="hljs-built_in">calc</span>(i,b,p-c[i]<span class="hljs-number">-1</span>))--r;<br>                    q[++r] = p-c[i]<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>        ans = std::<span class="hljs-built_in">max</span>(ans,f[i]);<br>    std::cout&lt;&lt;ans&lt;&lt;std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h4><p>做 $t$ 次01背包即可。</p><h4 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h4><p>分别使用对应的转移方法做dp。</p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211102郑外模拟赛</title>
    <link href="/2021/11/02/20211102%E9%83%91%E5%A4%96%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    <url>/2021/11/02/20211102%E9%83%91%E5%A4%96%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求随机生成的有 $n$ 个节点的二叉树叶节点的期望个数。  </p><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>结论题，对于一棵有 $n$ 个节点随机生成的二叉树，叶节点的期望个数为 <strong>$\frac{n(n+1)}{2(2n+1)}$</strong></p><h4 id="不严谨证明"><a href="#不严谨证明" class="headerlink" title="不严谨证明"></a>不严谨证明</h4><p>设叶节点总数为 $g_n$ ,树形态总数为 $f_n$ , 则结果为 $\frac{g_n}{f_n}$  </p><p>通过打表观察可知， $g<em>n=nf</em>{n-1}$ 原式可化为 $\frac{n*f_{n-1}}{f_n}$</p><p>由 ${f_n={2n}\choose{n} }$ </p><p>可得原式又可化为 $\frac{n(n+1)}{2(2n+1)}$ ，原结论得证。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一张有 $n+2$ 个点， $m_1$ 条免费单向边， $m_2$ 条付费单向边的图与手中的钱数 $k (k\leq 50)$ ，求 $0$ 点与 $n+1$ 点的严格次短路。</p><h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>不容易，终于在考场上相出了一次正解。 <del>虽然没写出来</del>  </p><p>观察到 $k$ 的范围很小，因此可以考虑建立一个有 $k$ 层的分层图，第 $i$ 层代表使用了 $(i-1)$ 次付费边。<br>然后将每一层的起点与终点相互连起来，这样最后的结果便是从第 $1$ 层的 $0$ 点出发，到第 $k$ 层的 $n+1$ 点的最短路了。<br>为什么要将每一层的起点和终点连起来呢？ 因为我们首先要保证跑出来的是 <strong>最短路</strong> ，下一步才是严格次短路。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>数据结构优化dp,可能我以后就看懂了吧。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个节点，每个节点有一个海拔值 $a_i$ ，每个节点都会向海拔值小于它点的节点连一条单向边。<br>再给定 $k$ 个操作，每次操作会给定两个参数 $L,R$ ，对于每条单向边 $(u,v),u,v\in [L,R]$ 取反 （将边的方向调换）。<br>求在经过 $k$ 次操作后 <strong>本质不同</strong> 三元环的个数.</p><h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>寻找三元环相对困难，但求 $n$ 个点可能组成三元环的个数十分简单： ${n}\choose{3}$ 。</p><p>而求所有不可能组成的三元环的个数也十分简单： $\sum\limits_{i=1}^{n}{ {r_i}\choose{2} }$ , $r_i$ 代表第 $i$ 个点的出边个数。</p><p>因为对于每个点，任选两条出边，一定构不成三元环。</p><p>因此答案便是 ${ {n}\choose{3} }-\sum\limits_{i=1}^{n}{ {r_i}\choose{2} }$ </p><p>现在考虑如何维护 $r_i$ </p><p>首先，看到取反操作，我们可以很自然地想到异或。<br>而我们发现，每个 $a_i$  </p><ul><li>对于所有海拔 $a_j\in [1,a_i)$ 的节点，若无标记，则有出边。</li><li>对于所有海拔 $a<em>j\in (a_i+1,a</em>{max}]$ 的节点，若有标记，则有出边。</li></ul><p>因此求 $r_i$ 转化为了，对于每个节点 ，求海拔小于 $a_i$ 的无标记的点与海拔大于 $a_i$ 的有标记的点的个数和。<br>这个信息可以用线段树维护。</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>杂题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211101郑外模拟赛总结</title>
    <link href="/2021/11/01/20211101%E9%83%91%E5%A4%96%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    <url>/2021/11/01/20211101%E9%83%91%E5%A4%96%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟赛总结"><a href="#模拟赛总结" class="headerlink" title="模拟赛总结"></a>模拟赛总结</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> 对于一个长为 $n$ 的序列 $a_1,a_2,\dots,a_n$ ，给定另一个长为 $2^m$ 的序列，记为 $p_1,p_2,\dots,p_n$ ,定义 $p_i$ 的值为  </p><p>$p<em>i=\mathop{\max}\limits</em>{1\leq j\leq n}a_j\oplus i$ 求所有可能的 $a$ 的情况。</p><h3 id="赛时思路"><a href="#赛时思路" class="headerlink" title="赛时思路"></a>赛时思路</h3><p>考场上，看到异或，首先想到01Trie，但还是太年轻了。</p><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>首先，明确： $\forall i\in[1,n]$ , 必有 $\mathcal{p}<em>{a</em>{i-1}+1\sim a_i}=i$   <del>等待证明，先用着这个结论吧</del></p><p>所以一个合法的构造 ${p}$ 必定完整的出现 $[1,n]$ 。</p><p>按二进制从高位到低位（从左到右）考虑 $i\in[0,2^m-1]$  。</p><p>因为给定的 $p$ 的长度为 $2$ 的幂次，因此异或时的下标 $i$ 可从中分为两组: 一组是下标的第 $k$ 位为 $1$ 的，一种是为 $0$ 的。而异或又有贪心的性质。因此可以考虑分治。</p><p>分治状态 $[l,r]$ 表示 $\forall i\in[l,r],i\oplus a_{p_i}$ 在第 $dep$  位前完全相同。$dep$ 指分治的层数。</p><p>对 $p<em>l,p</em>{l+1},\dots,p_r$ 进行分类讨论。</p><p>若前半段的每个 $p<em>i$ 与后半段的每个 $p</em>{i+mid}$ 相等，则 $a<em>{p_l},a</em>{p<em>{l+1}},\dots,a</em>{p_r}$ 的第 $dep$ 位为  <strong>$1$ 或 $0$</strong>  ，因此有两种方案。方案数乘 $2$ 后成为规模减半的子问题。</p><p>若前半段与后半段的对应位置上的 $p$ 值不同，则  $a<em>{p_l},a</em>{p<em>{l+1}},\dots,a</em>{p_r}$ 的第 $dep$ 位同时有 $1$ 与 $0$ ，此时为了最大值，只有选与对应 $p$ 的第 $dep$ 位相反的二进制值，因此只有一种情况。 同时，有些对应位置上的 $p$ 值可能相同，此时 $a$ 的第 $dep$ 位不可能既是 $0$ 又是 $1$ ，因此要判无解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)<br>        apr[a[i]] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; ++i)<br>        flag |= a[i] ^ a[i + mid - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (!flag)<br>        ans &lt;&lt;= <span class="hljs-number">1</span>, ans %= mod, <span class="hljs-built_in">solve</span>(l, mid);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; ++i)<br>            apr[a[i]] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> + mid; i &lt;= r; ++i)<br>            <span class="hljs-keyword">if</span> (apr[a[i]])<br>            &#123;<br>                ans = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">clear</span>(l, mid);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        <span class="hljs-built_in">clear</span>(l, mid);<br>        <span class="hljs-built_in">solve</span>(l, mid), <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//============================================</span><br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-comment">//============================================</span><br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    m = <span class="hljs-number">1</span> &lt;&lt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>        std::cin &gt;&gt; a[i], apr[a[i]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!apr[i])<span class="hljs-comment">//判断，若[1,n]有没出现过的,直接判无解</span><br>            <span class="hljs-keyword">return</span> std::cout&lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; std::endl, <span class="hljs-number">0</span>;<br>    &#125;<br>    std::<span class="hljs-built_in">fill</span>(apr, apr + n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//清空，准备solve时复用</span><br>    <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>);<span class="hljs-comment">//分治</span><br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下次看到这种题，一定要考虑各种利用二进制的各种特性进行分治。</p><p>类似的题，大多可以转化为一棵二叉树，并且可以利用子树信息进行分治。</p><p><a href="(http://www.zhengruioi.com/contest/1020/problem/1950">一道类似的题</a>)</p><hr><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$ 个点 ,已经连了 $m$ 条边的图，要求在给定系数 $K$ 的情况下，将这张图连成一张完全图。</p><p>系数 $K$ 的定义是在连边时，需满足 1.连接的两点之间没有边。2.两点的度数和不小于 $K$ 。</p><p>现在需要我们求最小的 $K$。</p><h3 id="赛时"><a href="#赛时" class="headerlink" title="赛时"></a>赛时</h3><p>想到了贪心的思路：</p><p>用 <code>std::pair&lt;int,int&gt;</code> 储存每个点的编号与度数，存入大根堆中，每次取堆顶并与所有没有连过边的点连边，当度数为 <code>n-1</code> 时弹出。不难发现，这是个 $\mathcal{O{n^3\log n}}$ 的算法。对于 $3e5$ 的数据，复杂度还是太高了。</p><h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>考虑按每个点的度数分类。因为度数最多为 $n-1$ ，因此度数和一定不大于 $2\times n$ 。</p><p>所以在进行加边操作时，若度数和大于现在的 $K$ ，则直接连边，否则考虑 $K$ 减小后新建的队列并加入。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这种思路与哈希表相似，都是”用空间换时间”。之后见到这样时间复杂度瓶颈在 $log$ 上的题，可以考虑将树状数据结构换成线性表。</p><hr><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>没改，但学到了一种思路。</p><p>对于有“依赖性的”操作，可以考虑按时间二分分治维护 <del>cdq分治！？</del></p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>求最少交换多少次相邻的元素可使数列单峰（不严格）</p><h2 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h2><p>思路是正解，实现锅的离谱。</p><h2 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h2><p>看到这种 “交换”，”单峰”。立刻想到树状数组。</p><p>观察题意可知，需要 “交换多少次”，其实就是在左面与右面有多少个数比当前数要小的最小值。</p><p>因此可直接树状数组维护。</p><p>记左边比当前数小的数的个数为 $ls_i$ ,右边为 $rs$ 。</p><p>答案就是 $\sum_\limits{i=1}^{n}min(ls_i,rs_i)$</p><blockquote><p>小技巧：在输入时，直接使用 <code>n-a[i]+1</code> 代替 <code>a[i]</code> ,之后可直接使用树状数组统计。</p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>还是要多学学树状数组的各种神奇操作呀。</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树学习笔记</title>
    <link href="/2021/10/30/Trie%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/30/Trie%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Trie树(又称前缀树)是一种用来解决多字符串、前缀、匹配的数据结构。<br>其核心思想是利用字符串之间的相同部分来加速检索的过程。<br>例如，water，wish，win，tie，tired这几个单词可以用以下方式存储<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="引用自算法学习笔记(43): 字典树">[1]</span></a></sup>：<br><img src="1.jpg" alt="一棵Trie树"></p><p>可以发现，字符串的大部分信息都是靠边来维护的，节点只起到辅助作用。<br>同时，这还是一种以空间换时间的数据结构。<br>通过消耗 字符串最大长度 $\times$ 26 的空间， 来达到 $\mathcal{O(|S|_{max})}$ 的查询。<br>可以发现，查找的复杂度与数据规模无关，只与字符串长度有关。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span>+<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> nxt[maxn][<span class="hljs-number">26</span>],cnt = <span class="hljs-number">1</span>;<span class="hljs-comment">//令初始的特殊节点值为1</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">memset</span>(nxt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(nxt));<br>        cnt = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)<br>        &#123;<br>            <span class="hljs-comment">//如果可以复用之前节点，直接用，，反之新建节点。</span><br>            <span class="hljs-keyword">if</span>(!nxt[cur][c-<span class="hljs-string">&#x27;a&#x27;</span>])<br>                nxt[cur][c-<span class="hljs-string">&#x27;a&#x27;</span>] = ++cnt;<br>            cur = nxt[cur][c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findPrefix</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span><span class="hljs-comment">//原理同插入</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!nxt[cur][c-<span class="hljs-string">&#x27;a&#x27;</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = nxt[cur][c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这里放一道裸题<a href="https://www.luogu.com.cn/problem/P2292">L语言</a>  </p><p>本题大意是给定 $n$ 个原串，求每个询问的串能由原串组成的最长前缀。</p><p>解法很简单，就是在Trie树上循环匹配，同时使用哈希表记录已知答案(推一波<code>__gnu_pbds::gp_hash_table</code>)。</p><h2 id="PBDS"><a href="#PBDS" class="headerlink" title="PBDS!!!"></a>PBDS!!!</h2><p>既然提到了<code>pbds</code>，那就提一嘴它吧！。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/trie_policy.hpp&gt;</span></span><br><br><span class="hljs-comment">//平时考试中不要using namespace，要一个一个加在相应的类名前</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> trie&lt;string,null_type&gt; tre;<br>tre tr;<br></code></pre></div></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">tr.<span class="hljs-built_in">insert</span>(s);<span class="hljs-comment">//插入一个字符串s</span><br>tr.<span class="hljs-built_in">erase</span>(s);<span class="hljs-comment">//删除一个字符串s</span><br>tr.<span class="hljs-built_in">join</span>(oth);<span class="hljs-comment">//将两棵trie合并在一起。</span><br>tr.<span class="hljs-built_in">prefix_range</span>(s);<span class="hljs-comment">//返回 pair&lt;ItrBegin,ItrEnd&gt;,是一对指向以s为前缀的所有字符串的迭代器(左闭右开)。</span><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>引用自<a href="https://zhuanlan.zhihu.com/p/173981140">算法学习笔记(43): 字典树</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20101029模拟赛总结</title>
    <link href="/2021/10/29/20211029%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/29/20211029%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p> 大意描述：给定 $n$ 个字符串、 $m$ 个询问。对于每个询问，给定两个字符串 $S,T$，问 $n$ 个字符串中满足 $S$ 为其前缀， $T$ 为其后缀的字符串有多少个。  </p></blockquote><h3 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h3><p>Trie的裸题，对每个字符串，正着反着各建一颗Trie。每次询问暴力在相应的Trie中查询。</p><h3 id="满分做法"><a href="#满分做法" class="headerlink" title="满分做法"></a>满分做法</h3><p>转 $dfs$ 序后即矩形求和，时间复杂度 $\mathcal{O(n\log n)}$。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>没改</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><a href="[3417 -- Network (poj.org">原题</a>](<a href="http://poj.org/problem?id=3417">http://poj.org/problem?id=3417</a>))</p><p>树上差分。</p><p>考虑每条非树边，发现它们会与树边一起构成一个环，为了使图不连通，第一步在切断 $x,y$ 之间的树边后，下一步必定要切断附加边 $(x,y)$ 。因此原题可转化为 <strong>求每条树边被非树边覆盖了多少次</strong></p><p>而解决这一类问题的方法，便是”树上差分”。</p><p>令每个点的初始权值为 $0$ ,对每条非树边 $(x,y)$，令节点 $x$ 与 $y$ 的权值增加 $1$,令 $lca(x,y)$ 的权值减少 $2$ </p><p>最后进行一次 $dfs$ ,求出 <code>F[x]</code> 代表以 <code>x</code> 为根的子树权值和。 <code>F[x]</code> 就是 <code>x</code> 与其父节点之间的“树边”的覆盖次数。时间复杂度 $\mathcal{O(n+m)}$ 。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>没改</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20101027模拟赛总结</title>
    <link href="/2021/10/27/20101027%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/27/20101027%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>观察题目性质可知，因为是求在 $\bmod 2$ 意义下的的解，因此交换两个位置上的树产生的影响会被 $\pmod 2$ 消除掉，因此直接求出 $1$ 个数的前缀和，询问时回答区间中两数的“1”个数之差 $\bmod2$ 的结果即可</p><hr><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>考场上想歪了，下来看其实思路一般难。</p><p>由<a href="http://poj.org/problem?id=3090">Visible Lattice Points</a>可得，在线上的任意两点之间的 $x,y$ 轴上坐标的 $gcd$ 必定相等，而数据范围又比较小，所以我们可以枚举线段的两个端点，再进行判断。</p><p>进一步思考发现，每一个小矩形内的情况是与它所处的位置无关的，同时图形还具有对称性（左右对称），因此可进一步将时间复杂度优化至 $ \mathcal{O}(TWH)$</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>((a - x) * (a - x) + (b - y) * (b - y));<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> g = std::__gcd(x, y);<span class="hljs-comment">//g-1：这条线上我们可以选的点数</span><br>    <span class="hljs-type">int</span> k = std::<span class="hljs-built_in">ceil</span>(d / <span class="hljs-built_in">dis</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, x / g, y / g));<span class="hljs-comment">//两点之间的最小间隔</span><br>    <span class="hljs-keyword">if</span> (k * (n - <span class="hljs-number">1</span>) &gt; g)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//需要的点数大于能选的点数</span><br>    <span class="hljs-type">int</span> res = C[g - <span class="hljs-number">1</span> - (n - <span class="hljs-number">1</span>) * (k - <span class="hljs-number">1</span>)][n - <span class="hljs-number">2</span>];<span class="hljs-comment">//要选（n-2）个小球</span><br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span> &amp;&amp; y != <span class="hljs-number">0</span>)res = (res + res) % mod;<span class="hljs-comment">//对称的情况</span><br>    res = (<span class="hljs-type">__int128_t</span>)res * (w - x + <span class="hljs-number">1</span>) * (h - y + <span class="hljs-number">1</span>) % mod;<br>    <span class="hljs-comment">//防止乘炸</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span><span class="hljs-comment">//组合数预处理</span></span><br><span class="hljs-function"></span>&#123;<br>    C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2000</span>; ++i)<br>        C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2000</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j)<br>            C[i][j] = (C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + C[i - <span class="hljs-number">1</span>][j]) % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        &#123;<br>            std::cout &lt;&lt; (w + <span class="hljs-number">1</span>)*(h + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= w; ++x)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= h; ++y)<br>                ans = (ans + <span class="hljs-built_in">calc</span>(x, y)) % mod;<br>        std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>题意：求一棵树，若最多能选择两棵子树来遍历，最多能遍历到多少节点。</p><p>解法：使用可并堆，每次遍历到一个节点时，先递归去合并它的子树，最后合并至根节点，则根节点的可并堆的堆顶便是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">100</span>;<br><br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>&gt; q[maxn];<br><span class="hljs-comment">//pbds的堆，默认pairing_heap，各项性能均优于stl，在dijstra时优于thin_heap</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    G::<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxn; ++i)<br>        q[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> fa = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> G;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[p]; i; i = e[i].nxt)<br>    &#123;<br>        <span class="hljs-type">int</span> to = e[i].to;<br>        <span class="hljs-keyword">if</span> (to == fa)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(to, p);<span class="hljs-comment">//先处理子树的合并情况</span><br>        q[p].<span class="hljs-built_in">join</span>(q[to]);<br>        q[to].<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[p].<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">break</span>;<br>        x += q[p].<span class="hljs-built_in">top</span>(), q[p].<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    q[p].<span class="hljs-built_in">push</span>(x);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">dfs</span>();<br>    std::cout &lt;&lt; q[<span class="hljs-number">1</span>].<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>没学过<strong>BM算法</strong>与<strong>多项式乘法</strong>，再加上2816次的多项式……<br>告辞！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211027ZR总结</title>
    <link href="/2021/10/27/20211027ZR%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/27/20211027ZR%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>一个小点：链式前向星遍历时，<code>if(to==fa)continue;</code>，不能 <code>return</code><br><del>是我太蠢了……</del></p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="http://www.zhengruioi.com/contest/1024/problem/2121">传送门</a></p><blockquote><p>给定两类操作：  </p><ol><li><code>a[i]+=b</code></li><li><code>a[i]*=b</code></li></ol><p>最多进行m次操作，求一个操作顺序，使操作后数组总乘积最大</p></blockquote><p>易知，1操作具有单调性，因此若取，肯定取的为操作1的前n大的b的前缀。<br>那么我们就可以用操作1以后的结果除以操作前的数，得出这一操作的权值。<br>然后我们发现该权值就是操作2中的b。<br>因此可贪心。</p><p>代码实现</p><p><a href="http://www.zhengruioi.com/submission/407312">%%%大佬</a></p><p>一点<strong>常数优化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Inc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> (a+=b)&gt;=mod?a-mod:a;&#125;<br></code></pre></div></td></tr></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">100</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> a[maxn], b[maxn], d[maxn], cnt, ans = <span class="hljs-number">1</span>;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> t, x, y;<br>    <span class="hljs-type">double</span> w;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;lhs, <span class="hljs-type">const</span> node &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> lhs.w &gt; rhs.w;<br>    &#125;<br>&#125; c[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Inc</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a += b) &gt;= mod ? a - mod : a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k, m;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        std::cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t, x, y;<br>        std::cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)b[x] = std::<span class="hljs-built_in">max</span>(b[x], y);<span class="hljs-comment">//操作1，若被选，必定第一个被选</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">2</span>)G[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">3</span>)c[++cnt] = (node)<br>        &#123;<br>            t, x, y, <span class="hljs-number">1.0</span> * y<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (b[i] &gt; a[i])<br>            G[i].<span class="hljs-built_in">emplace_back</span>(b[i] - a[i]);<span class="hljs-comment">//挑选第一个选时是否合算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        d[i] = a[i];<span class="hljs-comment">//第i个数操作2前缀和的第一项？</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        std::<span class="hljs-built_in">sort</span>(G[i].<span class="hljs-built_in">begin</span>(), G[i].<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">//stl的小trick</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : G[i])<br>        &#123;<br>            <span class="hljs-comment">//求出每个操作2对应的权值</span><br>            c[++cnt] = (node)<br>            &#123;<br>                <span class="hljs-number">2</span>, i, j, <span class="hljs-number">1.0</span> * (j + d[i]) / d[i]<br>            &#125;;<br>            d[i] += j;<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + cnt);<br>    <span class="hljs-type">int</span> lim = std::<span class="hljs-built_in">min</span>(cnt, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= lim; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (c[i].w &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (c[i].t == <span class="hljs-number">2</span>)a[c[i].x] = <span class="hljs-built_in">Inc</span>(a[c[i].x], c[i].y);<br>        <span class="hljs-keyword">else</span> ans = <span class="hljs-number">1ll</span> * ans * c[i].y % mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        ans = <span class="hljs-number">1ll</span> * ans * a[i] % mod;<br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>设数组 $A$ 代表第 $i$ 个人选了第 $A_i$ 袋零食。</p><p>上界显然为 $\sum^{n-1}_{i = 0}i,即 \frac{n\times(n-1)}{2}$ ,</p><p>下面我们来构造 $s = 1+ \sum_{i\in g}i(g\subseteq{2,3,\dots,n-1})$ 的情况。  </p><p>我们很容易可以想到令 $A_n = 1, A_1 = 2, A_i = i(i\in{2,3,\dots,n-1},i\notin g)$ ，然后从小到大枚举 $i\in g$ ，每次将 $A_i$ 赋值为最小的未被选择的数，可以发现这样能保证对于 $i\in g ,A_i&lt;i$  ，故<br>这种构造是成立的。</p><p>通过进一步计算，我们可以发现，这样构造出来的 $s\in{1}\cup [3,\frac{n\times (n-1)}{2}-2]\cup {\frac{n\times (n-1)}{2}}$<br>那么我们可以再针对剩下的 $s=2,s=0,s=\frac{n\times (n-1)}{2}-1$ 的情况进行构造  </p><ul><li>当 $s=0$ 时，令 $A_i=i(i\in {1,2,\dots,n})$ 即可。  </li><li>当 $s=2$ 时，令 $A_1=3,A_2=1,A_3=2,A_i=i(i\in{4,5,\dots,n})$</li><li>当 $s=\frac{n\times(n-1)}{2}-1$ 且 $n$ 为奇数时： $A_1=3,A_2=1,A_n=2,A_i=i+1(i\in{3,4,\dots,n-1})$  可以发现，这种思路就是在 $s=2$ 的基础上，同时保证了 $A_i&gt;i(i\in{3,4,\dots,n-1})$  </li><li>当 $s=\frac{n\times(n-1)}{2}-1$ 且 $n$ 为偶数时： 此时思路与 $s=0$ 时类似，是在保证 $A_i&gt;i(i\in{2,3,\dots,n-1})$ 的情况下，将 “1” 的贡献除去。此时可令 $A_1 = 1,A_n=2,A_i=i+1(i\in{2,3,\dots,n-1})$</li></ul><p>可以发现，这几层构造是逐步推进的。<br>可见，构造时，既可从特殊情况出发，观察交换任意两数后结果的不同，也可以从一般情况出发，再补充特殊情况时的构造。<br>还有<strong>构造时奇偶的差别！！！</strong>以及<strong>构造的结果的值域问题！！！</strong>（如这道题的一般构造方法会漏掉3个值）</p><p>普通情况时的构造方式：  </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">p[n] = <span class="hljs-number">1</span>, vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>, j = n; i &gt;= <span class="hljs-number">1</span>; --i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; s || i == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( ; j &gt;= <span class="hljs-number">1</span> &amp;&amp; vis[j]; --j) ;<br>        p[i] = j, vis[j] = <span class="hljs-number">1</span>, s -= i;<br>    &#125;<br>    <span class="hljs-keyword">else</span> p[i] = i, vis[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    std::cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></div></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><a href="https://www.cnblogs.com/cjyyb/p/9479258.html">TODO：长链剖分</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分块笔记</title>
    <link href="/2021/10/27/%E5%88%86%E5%9D%97%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/27/%E5%88%86%E5%9D%97%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这应该是我学的第一个根号算法/数据结构。<br>简单地说，这是一个只分了三层，每块大小为 $\sqrt{n}$ 的线段树，且顶层的数据无需维护。<br>这样就可以的到一个每次操作复杂度均摊 $\mathcal{O}{(\sqrt{n})}$ 的数据结构了。</p><p>那它的优点在哪里呢？<br>当然是维护不符合区间可加性的信息。如：  </p><ul><li>区间众数</li><li>区间本质不同的元素个数</li><li>…</li></ul><p>下面就让我们看一看实现吧。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>虽然尝试过使用<code>vector&lt;int&gt;</code> + 结构体的方式，但还是选择了去和<a href="https://zhuanlan.zhihu.com/p/105467597">Pecco大神</a>学好写的分块码风。 <del>不要学压行！！！</del></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="块的首尾"><a href="#块的首尾" class="headerlink" title="块的首尾"></a>块的首尾</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sq = <span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-type">int</span> st[maxn],ed[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=sq;++i)<br>&#123;<br>    st[i] = n / sq * (i - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    ed[i] = n / sq * i;<br>&#125;<br>ed[sq] = n; <br></code></pre></div></td></tr></table></figure><h4 id="每个数属于哪个块"><a href="#每个数属于哪个块" class="headerlink" title="每个数属于哪个块"></a>每个数属于哪个块</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> bel[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=sq;++i)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = st[i];j&lt;=ed[i];++j)<br>        bel[j] = i;<br></code></pre></div></td></tr></table></figure><h4 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> siz[maxn];<span class="hljs-comment">//防止与std::里的变量/函数名的冲突。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=sq;++i)<br>    siz[i] = ed[i] - st[i] + <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>这样分块所需的数据就预处理出来了。</p><h3 id="例题：线段树1"><a href="#例题：线段树1" class="headerlink" title="例题：线段树1"></a>例题：<a href="https://www.luogu.com.cn/problem/P3372">线段树1</a></h3><p>从这一题，大家可以来理解一下块状数组“大分块，小暴力”的思想。<br>具体请看代码注释。</p><h4 id="额外的初始化与数组"><a href="#额外的初始化与数组" class="headerlink" title="额外的初始化与数组"></a>额外的初始化与数组</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum[maxn],mark[maxn];<span class="hljs-comment">//区间和与延迟标记</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=sq;++i)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = st[i];j&lt;=ed[i];++j)<br>        sum[i]+=a[j];<span class="hljs-comment">//a为原数组</span><br></code></pre></div></td></tr></table></figure><h4 id="区修"><a href="#区修" class="headerlink" title="区修"></a>区修</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bl = bel[l],br = bel[r];<span class="hljs-comment">//先存下来，防止重复寻址对常数因子的影响</span><br>    <span class="hljs-keyword">if</span>(bl==br)<span class="hljs-comment">//在同一块内，直接暴力</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bl;i&lt;=br;++i)<br>            a[i]+=val,sum[bl]+=val;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">//否则先处理散块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i&lt;=ed[bl];++i)<br>        a[i]+=val,sum[bl]+=val;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = st[br];i&lt;=r;++i)<br>        a[i]+=val,sum[br]+=val;<br>    <span class="hljs-comment">//再处理整块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bl+<span class="hljs-number">1</span>;i&lt;br;++i)<br>        mark[i]+=val;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="区查"><a href="#区查" class="headerlink" title="区查"></a>区查</h4><p>同理，不过要记得“标记永久化”，查询时要加标记。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bl = bel[l],br = bel[r];<span class="hljs-comment">//先存下来，防止重复寻址对常数因子的影响</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(bl==br)<span class="hljs-comment">//在同一块内，直接暴力</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bl;i&lt;=br;++i)<br>            ans+=a[i]+mark[bl];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//否则先处理散块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i&lt;=ed[bl];++i)<br>        ans+=a[i]+mark[bl];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = st[br];i&lt;=r;++i)<br>        ans+=a[i]+mark[br];<br>    <span class="hljs-comment">//再处理整块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bl+<span class="hljs-number">1</span>;i&lt;br;++i)<br>        ans+=sum[i]+mark[i]*siz[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论基础知识速览</title>
    <link href="/2021/10/22/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/"/>
    <url>/2021/10/22/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> G<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>;<br><span class="hljs-keyword">typedef</span> Edge* lpEdge;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    lpEdge nxt;<br>    <span class="hljs-type">int</span> to, w;<br>&#125;e[maxn];<br>lpEdge head[maxn];<br>lpEdge cnt = e + <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> tmp = ++cnt;<br>    tmp-&gt;nxt = head[u];<br>    head[u]  = tmp;<br>    tmp-&gt;to  = v;<br>    tmp-&gt;w   = w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">add</span>(u,v,w), <span class="hljs-built_in">add</span>(v,u,w);<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="倍增LCA"><a href="#倍增LCA" class="headerlink" title="倍增LCA"></a>倍增LCA</h3><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fa[maxn][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> dep[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> f = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    dep[p] = dep[f]+<span class="hljs-number">1</span>;<br>    fa[p][<span class="hljs-number">0</span>] = f;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>        <span class="hljs-built_in">dfs</span>(e-&gt;to,p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ;j&lt;=<span class="hljs-number">20</span>;++j)<br>            fa[i][j] = fa[fa[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[a]&lt;dep[b])<br>        std::<span class="hljs-built_in">swap</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ;i&lt;=<span class="hljs-number">20</span>;++i)<br>        <span class="hljs-keyword">if</span>(dep[fa[a][i]]&lt;dep[y])a = fa[a][i];<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;++i)<br>        <span class="hljs-keyword">if</span>(fa[a][i]!=fa[b][i])<br>            a = fa[a][i],b = fa[b][i];<br>    <span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote><p>用途：将一张DAG，拉成一条对于每条边<code>(u,v)</code>, $u$ 总是大于 $v$ 的链</p></blockquote><p>实现：一般都是采用 <strong>Kahn</strong> 算法，也就是不断地删去入度为 $0$ 的点，最后将整张图删去。<br>这里以一道例题来讲解：<br><a href="https://www.luogu.com.cn/problem/P1137">P1137 旅行计划</a></p><p>核心代码：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topoSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        f[i] = <span class="hljs-number">1</span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i  = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (!in[i])q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">//将入度为 $0$ 的点删去，加入待扩展的集合</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> now = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[now];e;e = e-&gt;nxt)<br>        &#123;<br>            f[e-&gt;to] = std::<span class="hljs-built_in">max</span>(f[to], f[now] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(!--in[e-&gt;to])q.<span class="hljs-built_in">push</span>(to);<span class="hljs-comment">//若删去一点后，该点入度为 $0$ ，则加入集合</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="SPFA判负环"><a href="#SPFA判负环" class="headerlink" title="SPFA判负环"></a>SPFA判负环</h3><blockquote><p>引理: 若一张图无负环，则在SPFA过程中每个点最多被更新 $n-1$ 次。</p></blockquote><p>因此我们可以额外增加一个数组<code>vis</code>来记录更新次数。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dis[maxn],vis[maxn];<br><span class="hljs-type">bool</span> inQueue[maxn];<br><span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        inQueue[p] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[e-&gt;to] &gt; dis[p] + e-&gt;w)<br>            &#123;<br>                dis[e-&gt;to] = dis[p] + e-&gt;w;<br>                <span class="hljs-keyword">if</span>(!inQueue[e-&gt;to])<br>                &#123;<br>                    inQueue[e-&gt;to] = <span class="hljs-number">1</span>;<br>                    ++vis[e-&gt;to];<br>                    <span class="hljs-keyword">if</span>(vis[e-&gt;to]&gt;n)<br>                    &#123;<br>                        flag = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">return</span> ;<br>                    &#125;<br>                    Q.<span class="hljs-built_in">push</span>(e-&gt;to);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Tarjan有向图求强连通分量-amp-缩点"><a href="#Tarjan有向图求强连通分量-amp-缩点" class="headerlink" title="Tarjan有向图求强连通分量&amp;缩点"></a>Tarjan有向图求强连通分量&amp;缩点</h3><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> low[maxn],dfn[maxn],tim,scc[maxn],cScc;<br><span class="hljs-type">bool</span> inStack[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    low[p] = dfn[p] = ++tim;<br>    inStack[p] = <span class="hljs-number">1</span> ;<br>    st.<span class="hljs-built_in">push</span>(p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!dfn[e-&gt;to])<br>        &#123;<br>            <span class="hljs-built_in">Tarjan</span>(e-&gt;to);<br>            low[p] = std::<span class="hljs-built_in">min</span>(low[p],low[e-&gt;to]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStack[e-&gt;to])<br>            low[p] = std::<span class="hljs-built_in">min</span>(low[p],dfn[e-&gt;to]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low[p]==dfn[p])<br>    &#123;<br>        <span class="hljs-type">int</span> top;<br>        ++cScc;<br>        <span class="hljs-keyword">do</span>&#123;<br>            top = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            inStack[top] = <span class="hljs-number">0</span>;<br>            scc[top] = cScc;<br>        &#125;<span class="hljs-keyword">while</span>(top!=p)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reBuild</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head[p];e;e = e-&gt;nxt)<br>            <span class="hljs-keyword">if</span>(scc[i]!=scc[e-&gt;to])<br>                G::<span class="hljs-built_in">add</span>(scc[i],e-&gt;to)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<br>        <span class="hljs-keyword">if</span>(!dfn[i])<br>            <span class="hljs-built_in">Tarjan</span>(i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, sz[MAXN], mss[MAXN];<span class="hljs-comment">//mss:Maximum Subtree Size</span><br>vector&lt;<span class="hljs-type">int</span>&gt; ctr;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRoot</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> fa = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    sz[p] = <span class="hljs-number">1</span>, mss[p] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e = G::head;e;e = e-&gt;nxt)<br>        <span class="hljs-keyword">if</span>(e-&gt;to!=fa)<br>        &#123;<br>            <span class="hljs-built_in">getRoot</span>(e-&gt;to,p);<br>            mss[p] =std::<span class="hljs-built_in">max</span>(mss[p],siz[e-&gt;to]);<br>            sz[p] += sz[e-&gt;to];<br>        &#125;<br>    mss[p] = <span class="hljs-built_in">max</span>(mss[p], n - sz[p]);<br>    <span class="hljs-keyword">if</span> (mss[p] &lt;= n / <span class="hljs-number">2</span>)<br>        ctr.<span class="hljs-built_in">push_back</span>(p);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学基础知识速览</title>
    <link href="/2021/10/22/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/"/>
    <url>/2021/10/22/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%80%9F%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h3 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h3><h4 id="《九章算术》“更相减损法”"><a href="#《九章算术》“更相减损法”" class="headerlink" title="《九章算术》“更相减损法”"></a>《九章算术》“更相减损法”</h4><p>内容: $gcd(a,b) = gcd(b,a-b)$<br>效率有点低，但在高精除法难以实现时，可代替欧几里得算法。<br><del>狗都不写高精</del></p><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>内容: $gcd(a,b) = gcd(b,a \bmod b)$ ，当 $b$ 为 $0$ 时，返回 $a$ 。<br>最常用的gcd算法。</p><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>内容：<code>__gcd()</code><br>亲测，在1e8的数据下，手写三目运算符23秒多，<code>__gcd</code>19秒。</p><h4 id="Exgcd"><a href="#Exgcd" class="headerlink" title="Exgcd"></a>Exgcd</h4><p>在gcd的每一步运算后，新得到的结果是由前两个参数线性组合而成.<br>所以可以在gcd过程中顺便求出 $a{\times}x+b{\times}y=c$ 的解<br>具体证明请看这篇博客： <a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得</a><br>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> <span class="hljs-comment">//引用传参，直接得到结果</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b ,a % b ,y ,x);<br>    y -= (a / b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p><strong>前提：互质！！！</strong></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>大白话：模意义下的 $\frac{1}{a}$<br>形式化语言：若 $ax=1 \pmod p$ ,则称 $x$ 为 $a$ 在模 $p$ 意义下的逆元</p><h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><h5 id="Exgcd-1"><a href="#Exgcd-1" class="headerlink" title="Exgcd"></a>Exgcd</h5><p>观察定义可得原式等价于 $ax+py≡1 \pmod p$ ,因此可直接使用exgcd求解，但要注意判断不互质时无解<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">getInv</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll x,y;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exgcd</span>(a,p,x,y)!=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> (x % p + p) % p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h5><blockquote><p>定理：$a^{p}≡a \pmod p$</p></blockquote><p>由此得，$\frac{1}{a}=a^{p-2}$ （模意义下）</p><h5 id="线性推逆元"><a href="#线性推逆元" class="headerlink" title="线性推逆元"></a>线性推逆元</h5><p>上方都是 $log n$ 级别的算法，但有些毒瘤题可能需要线性筛。</p><blockquote><p>递推式： $inv(a)=-⌊p/a⌋× inv(p\bmod b)\pmod p$<br>代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ll inv[maxn] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a % p + p) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getInv</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=a;++i)<br>        inv[i] = <span class="hljs-number">1ll</span> * (p - p / i) * inv[p % i] % p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="筛素数"><a href="#筛素数" class="headerlink" title="筛素数"></a>筛素数</h4><p>直接线性筛，每个数都由自己的最小质因子筛掉<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; prime;<br><span class="hljs-type">bool</span> isnp[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!isnp[i])<br>            prime.<span class="hljs-built_in">emplace_back</span>(i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:prime)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p * i &gt; n)<br>                <span class="hljs-keyword">break</span>;<br>            isnp[p * i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % p == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理-CRT"></a>中国剩余定理-CRT</h3><blockquote><p>搬自<a href="https://zhuanlan.zhihu.com/p/103394468">中国剩余定理</a></p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">CRT</span><span class="hljs-params">(ll a[], ll b[], ll n)</span>  <span class="hljs-comment">// a是模数数组，b是余数数组，n是数组长度</span></span><br><span class="hljs-function"></span>&#123;<br>    ll p = <span class="hljs-number">1</span>,x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)<br>        p *= a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>        r = p / a[i];<br>        x += (b[i] * r * <span class="hljs-built_in">inv</span>(r , a[i])) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x % p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><blockquote><p>内容： <script type="math/tex">C_{m}^{n}=C_{n\bmod p}^{m\bmod p}⋅C_{⌊n/p⌋}^{⌊m/p⌋}</script></p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fac[maxn],inv[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getInv</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;p;++i)<br>        inv[i] = <span class="hljs-number">1ll</span> * (p - p / i) * inv[p % i] % p;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> m &lt; n ? <span class="hljs-number">0</span> : fac[m] * <span class="hljs-built_in">inv</span>(fac[n], p) % p * <span class="hljs-built_in">inv</span>(fac[m - n], p) % p;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> % p : <span class="hljs-number">1ll</span> * <span class="hljs-built_in">lucas</span>(n / p, m / p, p) * <span class="hljs-built_in">C</span>(m % p, n % p, p) % p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p> 定义： 小于 $n$ 的与 $n$ 互质的树的个数称为欧拉函数，记作 $\varphi(n)$</p><p>性质：</p><ol><li>若 $p$ 为质数，则 $\varphi(p)=p-1$</li><li>若 $a∣x$ 则 $\varphi(ax) = aφ(x)$</li><li>若 $a,b$ 互质，则 $φ(a)φ(b) = φ(ab)$</li></ol><p>由此我们可以发现，欧拉函数与质数有一定的关系，因此我们可以在筛质数的过程中顺便求出<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> isnp[maxn];<br><span class="hljs-type">int</span> phi[maxn];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; prime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPhi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!isnp[i])<br>            prime.<span class="hljs-built_in">emplace_back</span>(i),phi[i] = i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:prime)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i*p&gt;n)<br>                <span class="hljs-keyword">break</span>;<br>            isnp[i*p] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i%p==<span class="hljs-number">0</span>)<br>            &#123;<br>                phi[i * p] = phi[i] * p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> phi[i * p] = phi[i] * phi[p];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ex-BSGS"><a href="#ex-BSGS" class="headerlink" title="(ex)BSGS"></a>(ex)BSGS</h3><p>大步小步算法可以视为对枚举法求 $a^x \equiv b \pmod m,\gcd(a,m)=1$ 的 $x$ 的一种改进。</p><p>我们知道当 $a,m$ 互质时，有 $a^{\varphi(m)} \equiv 1 \pmod m$<br>因此，我们可以在最坏 $\mathcal{O}(m-1)$ 的复杂度下解决这个问题。</p><p>但是，当 $m$ 过大时，复杂度依然无法接受。因此，我们可以采用类似折半搜索的方法，将 $m$ 表示为 $At-B$ ，然后将问题转化为 $a^{At}\equiv ba^B \pmod m$ 。<br>转化之后，我们就可以预先算出右边所有的可能值，然后再计算左边所有的可能值。当我们发现左边算出的值已经在右边出现过了，此时的 $A,B$ 即为所求。</p><p>这时，我们发现 $A$ 可能的取值有 $\lfloor \varphi(m)/t\rfloor$ 个， $B$ 的取值有 $\varphi(m) \mod t$ 个。理论上 $t$ 取 $\sqrt{\varphi(m)}$<br>最好，但为了避免计算 $\varphi$ ,我们可以直接取 $t = \sqrt m$ 。不难验证，此时取 $A,B\in [1,t]$ 可以保证把 $x\in [1,m-1]$ 全部枚举一遍。时间复杂度为 $\mathcal{O}(\sqrt m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">BSGS</span><span class="hljs-params">(ll a,ll b,ll p,ll k = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> __gnu_pbds::gp_hash_table&lt;ll,ll&gt; tb;<br>    tb.<span class="hljs-built_in">claer</span>();<br>    ll cur = <span class="hljs-number">1</span>, t = std::<span class="hljs-built_in">sqrt</span>(m) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B = <span class="hljs-number">1</span>;B &lt;= t; ++B)<br>    &#123;<br>        (cur *= a) %= p;<br>        tb [b * cur % p] = B;<br>    &#125;<br>    ll now = cur * k % p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A = <span class="hljs-number">1</span>; A &lt;= t; ++A)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = tb.<span class="hljs-built_in">find</span>(now);<br>        <span class="hljs-keyword">if</span>(it != tb.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-keyword">return</span> A * t - it-&gt;second;<br>        (now *= cur) %= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -INF;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">exBSGS</span><span class="hljs-params">(ll a,ll b,ll p,ll k = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll A = a%= p, B = b%= p,P = p;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll cur = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur == B)<span class="hljs-keyword">return</span> i;<br>        cur = cur * A % P;<br>        ll d = std::__gcd(a, p);<br>        <span class="hljs-keyword">if</span>(b % d)<span class="hljs-keyword">return</span> -INF;<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BSGS</span>(a,b,p,k * a % p) + <span class="hljs-number">1</span> + i;<br>        k = k * a / d % p, b /= d, p /= d;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题小点记录</title>
    <link href="/2021/10/17/%E6%9D%82%E9%A2%98%E5%B0%8F%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/17/%E6%9D%82%E9%A2%98%E5%B0%8F%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="杂题小点记录"><a href="#杂题小点记录" class="headerlink" title="杂题小点记录"></a>杂题小点记录</h1><h2 id="警钟长鸣"><a href="#警钟长鸣" class="headerlink" title="警钟长鸣"></a>警钟长鸣</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p>在 MinGW64 中， <code>algorithm</code> 库在开启 c++11 及以上的标准后会包含 <code>random</code> 库， 但在评测机上如果不手动包含 <code>random</code> 库的话则会报 <strong>CE</strong></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h4><p>在第二次dfs时要将根节点的 <code>top</code> 初始化为它自己。  </p><h4 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h4><p><code>mid = (r + l- 1) &gt;&gt; 1</code> ,要记得 -1 .</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>要写默认构造函数！！！</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) : <span class="hljs-built_in">a</span>(a), <span class="hljs-built_in">b</span>(b), <span class="hljs-built_in">c</span>(c) &#123;&#125;;<br>    <span class="hljs-built_in">foo</span>()=<span class="hljs-keyword">default</span>;<span class="hljs-comment">//不写这个,在这种数组初始化时就会报CE</span><br>&#125;bar[maxn];<br></code></pre></div></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="P2017"><a href="#P2017" class="headerlink" title="P2017"></a><a href="https://www.luogu.com.cn/problem/P2017">P2017</a></h3><p>拓扑序中前面的点a向后面的点b连边必定不会形成环</p><h3 id="2021-10-18模拟赛A"><a href="#2021-10-18模拟赛A" class="headerlink" title="2021.10.18模拟赛A"></a>2021.10.18模拟赛A</h3><p>统计有几个满足子树大小为 $d$ 的子树个数时，可选择使用辅助数组 <code>t</code> ,在dfs时 <code>++t[siz[p]]</code> ,查询时 <code>for(int i = 1;i*d&lt;=n;++i) s+=t[i*d]</code> 便可。</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="龟速乘的神奇写法"><a href="#龟速乘的神奇写法" class="headerlink" title="龟速乘的神奇写法"></a>龟速乘的神奇写法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">qmul</span><span class="hljs-params">(ll x,ll y,ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll z = (<span class="hljs-type">long</span> <span class="hljs-type">double</span>) x/p*y;<br>    ll res = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)x*y-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>) z*p;<br>    <span class="hljs-keyword">return</span> (res+p)%p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="切比雪夫定理"><a href="#切比雪夫定理" class="headerlink" title="切比雪夫定理"></a><a href="https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704">切比雪夫定理</a></h3><p>若整数 $n&gt;3$ ，则至少存在一个质数 $p$ ，符合 $n&lt;p&lt;2n-2$ 。另一个稍弱说法是：对于所有大于1的整数 $n$ ，存在一个质数 $p$ ，符合 $p&lt;n&lt;2p$ 。  </p><h3 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a><a href="https://baike.baidu.com/item/%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88/19858256">威佐夫博弈</a></h3><p>应用：P1290 <a href="https://www.luogu.com.cn/blog/ylx/solution-p1290">欧几里得游戏</a></p><h3 id="关于-gcd-的效率问题"><a href="#关于-gcd-的效率问题" class="headerlink" title="关于__gcd()的效率问题"></a>关于__gcd()的效率问题</h3><p>在 $1e8$ 的数据下，手写三目运算符23秒，<code>__gcd()</code>19秒。</p><h3 id="SuperGCD"><a href="#SuperGCD" class="headerlink" title="SuperGCD"></a><a href="https://www.luogu.com.cn/problem/P2152">SuperGCD</a></h3><p>Python代码 (考场打表可能会有用？)</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fractions<br><span class="hljs-built_in">print</span>(fractions.gcd(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()),<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())))<br></code></pre></div></td></tr></table></figure><h2 id="STL函数-amp-pbds"><a href="#STL函数-amp-pbds" class="headerlink" title="STL函数&amp;pbds"></a>STL函数&amp;pbds</h2><h3 id="std-fill-beg-end-val-可用于初始化"><a href="#std-fill-beg-end-val-可用于初始化" class="headerlink" title="std::fill(beg,end,val) ,可用于初始化"></a><code>std::fill(beg,end,val)</code> ,可用于初始化</h3><p>在数组大小为<code>1e5</code>,初始化次数<code>1e5</code>的情况下，<code>std::fill</code>约3400~3500ms,与手写速度差不多(开启O2).而<code>memset</code>为5000ms.</p><h3 id="宏定义与pbds"><a href="#宏定义与pbds" class="headerlink" title="宏定义与pbds"></a>宏定义与pbds</h3><p>在使用 __gnu_pbds::gp_hash_table<ll,ll> hs 时，若 #define int long long ，则会报错</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.9.2训练计划&amp;记录</title>
    <link href="/2021/09/02/2021-9-2%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/02/2021-9-2%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="倍增优化动态规划"><a href="#倍增优化动态规划" class="headerlink" title="倍增优化动态规划"></a>倍增优化动态规划</h3><ul><li><a href="https://www.luogu.com.cn/problem/P1613">P1613 跑路</a></li></ul><p>可在存图时加一维代表 $i,j间能否通过长为2^k的边$ 到达的。</p><ul><li><a href="https://www.luogu.com.cn/problem/P1081">P1081 开车旅行</a></li></ul><p>分别对A，B的距离 $2^k$ 的点进行预处理，之后再进行dp</p><ul><li><a href="https://www.luogu.com.cn/problem/P5024">P5024 保卫王国</a></li></ul><p>可像LCA一样预处理出第 $2^i$ 级祖先。</p><p>总结：无向图预处理出两点距离的 $2^k$ ，树处理自己的 $2^k$ 级祖先。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.31训练计划&amp;记录</title>
    <link href="/2021/08/31/2021-8-31%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2021/08/31/2021-8-31%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图匹配</a></li><li><a href="https://www.luogu.com.cn/problem/P2756">P2756 飞行员配对方案问题</a></li><li><a href="https://www.luogu.com.cn/problem/P1559">P1559 运动员最佳匹配问题</a></li></ul><p>模板题，练习了dinic的用法</p><ul><li><a href="https://www.luogu.com.cn/problem/P1129">P1129 [ZJOI2007]矩阵游戏</a></li></ul><p>可将坐标的对应关系转化为二分图的连边，之后若二分图匹配数为 $N$ 则游戏可行。</p><h3 id="网络流初步"><a href="#网络流初步" class="headerlink" title="网络流初步"></a>网络流初步</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3376">P3376 【模板】网络最大流</a></li><li><a href="https://www.luogu.com.cn/problem/P4722">P4722 【模板】最大流 加强版 / 预流推进</a></li></ul><p>学习了预流推进的优化</p><ul><li><a href="https://www.luogu.com.cn/problem/P2065">P2065 [TJOI2011]卡片</a></li></ul><p>连边时的小优化: gcd连边-&gt;质因数连边</p><ul><li><a href="https://www.luogu.com.cn/problem/P1345">P1345 [USACO5.4]Telecowmunication</a></li></ul><p>最小割的<strong>点</strong>模板题，转化时可将每个点拆成两个，之间用一条边权为1的边来连接</p><ul><li><a href="https://www.luogu.com.cn/problem/P2057">P2057 [SHOI2007]善意的投票</a></li></ul><p>本题可转化为最小割，之后求最大流即可。需要注意连边时需双向连。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过今天练习发现，大部分二分图匹配都可转化为费用流解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1018题解</title>
    <link href="/2021/08/30/P1018%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/30/P1018%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本题解主要介绍一些stl用法及小rick</p></blockquote><p>先贴上自己80分的代码：<a href="https://www.luogu.com.cn/record/57265108">蒟蒻的代码</a></p><p>来说做法，就是十分朴实的暴力枚举。</p><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><p>观察到 $N$ 很小，考虑暴力枚举状态。<br>这里我用的是<code>vector&lt;bool&gt;+next_permutation</code>,具体来说就是先将 $n-k-1$ 个 $0$ 扔进去，再把 $k$ 个 $1$ 扔进去，然后:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(next_permutation)<br>&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></div></td></tr></table></figure><br>整个循环的过程，复杂度是 $O(n^2)$ 的。</p><h3 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h3><p>下一步是字符串的处理，我用的是<code>std::atoll(char*)</code>,定义在<code>stdlib</code>中。这里有两点需要注意：</p><ol><li>字符串的类型为c风格，因此应调用<code>c_str()</code></li><li><code>string(__beg,__end)</code>构造函数的两个参数为迭代器，可运用<code>next(it,dis)</code>(等价于<code>while(dis--)++it</code>)来获得两个迭代器的地址。枚举时只需记录下标，更加直观。同时，这两个参数的范围为<strong>左闭右开区间</strong>，使用时需注意</li></ol><p>之后，我们只需要在枚举的过程中直接乘即可。具体处理代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br><span class="hljs-type">__uint128_t</span> tmp = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> ib = s.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (vec[i])<span class="hljs-comment">//vec为状态数组</span><br>    &#123;<br>        tmp *= <span class="hljs-built_in">atoll</span>(<span class="hljs-built_in">string</span>(<span class="hljs-built_in">next</span>(ib, now), <span class="hljs-built_in">next</span>(ib, i + <span class="hljs-number">1</span>)).<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-comment">//ll返回的为long long类型,i返回的为int类型，其他同理</span><br>        now = i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这里是扫了一遍状态数组，复杂度是 $O(n)$ 的。</p><h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><p>可以看到，我使用了<code>__uint128_t</code>。这个数据类型，如其名，占了128位，最多可记录3.4e38大小左右的数，而本题的数据给到了40位，足见出题人的用意。</p><blockquote><p>P.S. <code>__uint128</code>它并没有标准的输入输出，因此我们可以采用快读快写的方法来读入。</p><p>P.P.S. 同理，还有有符号的类型<code>__int128_t</code></p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>说到底，这道题的落脚点还是高精。毕竟 $N≤40$ , $O(n^3)$ 的算法最慢也只有20ms。但，10分钟80分也不失为一个很好的骗分方法。下面是80分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-type">int</span> n, k;<br>string s;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vec;<br><span class="hljs-type">__uint128_t</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">bool</span>&gt; &amp;vec)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">__uint128_t</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> len = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> ib = s.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vec[i])<br>        &#123;<br>            tmp *= <span class="hljs-built_in">atoll</span>(<span class="hljs-built_in">string</span>(<span class="hljs-built_in">next</span>(ib, now), <span class="hljs-built_in">next</span>(ib, i + <span class="hljs-number">1</span>)).<span class="hljs-built_in">c_str</span>());<br>            now = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (now != len)<br>    &#123;<br>        tmp *= <span class="hljs-built_in">atoll</span>(<span class="hljs-built_in">string</span>(<span class="hljs-built_in">next</span>(ib, now), s.<span class="hljs-built_in">end</span>()).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    ans =<span class="hljs-built_in">max</span>(tmp, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">__uint128_t</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">9</span>)<br>        <span class="hljs-built_in">print</span>(a / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(a % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; k;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - k - <span class="hljs-number">1</span>; ++i)<br>        vec.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)<br>        vec.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()))<br>    &#123;<br><br>        <span class="hljs-built_in">calc</span>(s, vec);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(ans);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>暴力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.26训练计划&amp;记录</title>
    <link href="/2021/08/25/2021-8-26%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/25/2021-8-26%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3870">P3870 [TJOI2009]开关</a></li><li><a href="https://www.luogu.com.cn/problem/P1903">[国家集训队]数颜色 / 维护队列</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P3396">P3396 哈希冲突</a></li></ul><p>本题分块时注意将块长设置为 $n^{\tfrac{1}{3}}$ 会更快，可能是因为模数都较小。</p><ul><li><a href="https://www.luogu.com.cn/problem/P3863">P3863 序列</a></li></ul><p>对于不同时间的操作，还可对时间分块进行离线查询</p><ul><li><a href="https://www.luogu.com.cn/problem/P1975">P1975 [国家集训队]排队</a></li></ul><p>使用逆序对性质后分块暴力做。（可转化为区间修改操作）</p><ul><li><a href="https://www.luogu.com.cn/problem/P3710">P3710 方方方的数据结构</a></li></ul><p>同样对时间分块，有关系的块之间还可使用线段树维护（其实相当于把树套树的节点换成分的块）。</p><ul><li><a href="https://www.luogu.com.cn/problem/P4168">P4168 [Violet]蒲公英</a></li></ul><p>众数拥有前缀和性质，因此可分块记录并查询，复杂度是 $O(nlogn)$ 的。</p><ul><li><a href="https://www.luogu.com.cn/problem/P2325">[SCOI2005]王室联邦</a></li></ul><p>树上分块</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.25训练计划&amp;记录</title>
    <link href="/2021/08/25/2021-8-25%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/25/2021-8-25%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h3><h4 id="线段树-树状数组套平衡树"><a href="#线段树-树状数组套平衡树" class="headerlink" title="线段树/树状数组套平衡树"></a>线段树/树状数组套平衡树</h4><ol><li><a href="https://www.luogu.com.cn/problem/P3380">P3380 【模板】二逼平衡树（树套树）</a></li><li><a href="https://www.luogu.com.cn/problem/P1903">P1903 [国家集训队]数颜色 / 维护队列</a><br>第二题需要使用set额外维护每一个颜色的前驱与后继</li></ol><h4 id="树状数组套权值线段树"><a href="#树状数组套权值线段树" class="headerlink" title="树状数组套权值线段树"></a>树状数组套权值线段树</h4><ol><li><a href="https://www.luogu.com.cn/problem/P1975">P1975 [国家集训队]排队</a></li><li><a href="https://www.luogu.com.cn/problem/P3759">P3759 [TJOI2017]不勤劳的图书管理员</a><br>转化时运用了逆序对性质(两题都使用了):<blockquote><p>在数列 $a$ 中，当 $x$ 交换到 $y$ 处后，区间 $[1,x-1]$ 与 $a_x$ 的逆序对不会改变，区间 $[y+1,n]$ 与 $a_x$ 的逆序对也不会改变，但是区间 $[x+1,y-1]$ 与 $a_x$ 的逆序对会改变.</p></blockquote></li></ol><h4 id="平衡树套线段树"><a href="#平衡树套线段树" class="headerlink" title="平衡树套线段树"></a>平衡树套线段树</h4><ol><li><a href="https://www.luogu.com.cn/problem/P3332">P3332 [ZJOI2013]K大数查询</a></li></ol><h4 id="树状数组维护扫描线"><a href="#树状数组维护扫描线" class="headerlink" title="树状数组维护扫描线"></a>树状数组维护扫描线</h4><ol><li><a href="https://www.luogu.com.cn/problem/P3242">P3242 [HNOI2015]接水果</a><br>本题可使用 DFS 序将问题转化成询问覆盖一个点的所有矩形中的第 k 小权值，之后便可使用扫描线。<blockquote><p>注意离散化</p></blockquote></li><li><a href="https://www.luogu.com.cn/problem/P5445">P5445 [APIO2019]路灯</a><br>两点之间的关系可转化为矩形间的关系（类似于二维差分）</li></ol><ul><li><a href="https://www.luogu.com.cn/problem/P3248">P3248 [HNOI2016]树</a><br><strong>真·树套树</strong><br>本题的数据范围较大，若使用传统树套树，会MLE，因此考虑在节点中记录这棵树在模板树上的对应关系（类似记录下标）便可解决。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.24训练计划&amp;记录</title>
    <link href="/2021/08/24/2021-8-24%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/24/2021-8-24%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3879">P3879 [TJOI2010]阅读理解</a></li><li><a href="https://www.luogu.com.cn/problem/P2292">P2292 [HNOI2004]L语言</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P2922">P2922 [USACO08DEC]Secret Message</a></li></ul><p>在储存原始信息的基础上多加了一个“以该字符串为前缀的字符串个数<code>sum</code>”。</p><ul><li><a href="https://www.luogu.com.cn/problem/P3065">P3065 [USACO12DEC]First!</a></li></ul><p>Trie与判环的结合。</p><ul><li><a href="https://www.luogu.com.cn/problem/P3294">P3294 [SCOI2016]背单词</a></li></ul><p>字符串后缀可转化为前缀（倒建Trie树），同时可记录字符串的末尾作为关键点并重新建图</p><ul><li><a href="https://www.luogu.com.cn/problem/P4407">P4407 [JSOI2009]电子字典</a></li></ul><p>建立Trie树后暴力枚举。复杂度只会乘上一个(1+26+26)=57的常数，可以接受。</p><ul><li><a href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></li></ul><p>根据异或性质构建0-1Trie贪心即可</p><h3 id="AC自动机入门"><a href="#AC自动机入门" class="headerlink" title="AC自动机入门"></a>AC自动机入门</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3808">P3808 【模板】AC自动机（简单版）</a></li><li><a href="https://www.luogu.com.cn/problem/P3796">P3796 【模板】AC自动机（加强版）</a></li></ul><p>KMP与Trie的结合</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.23训练计划&amp;记录</title>
    <link href="/2021/08/23/2021-8-23%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/23/2021-8-23%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希</a></li></ul><p>（pbds真香）</p><ul><li><a href="https://www.luogu.com.cn/problem/P5270">P5270 无论怎样神树大人都会删库跑路</a></li></ul><p>字符串的插入删除操作可以考虑使用hash来减少时间复杂度。</p><ul><li><a href="https://www.luogu.com.cn/problem/P5537">P5537 【XR-3】系统设计</a></li></ul><p>哈希的可减性: $即如果 u 是 v 的祖先，v 是 w 的祖先，则 (u,v) 的序列与 (v,w) 的序列拼接起来就是 (u,w) 的序列。$</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P4391">P4391 [BOI2009]Radio Transmission</a></li></ul><p>学到了一类转化：求原字符串s的最小循环子串，可转化为求原字符串s的最大公共前后缀</p><ul><li><a href="https://www.luogu.com.cn/problem/P3435">P3435 [POI2006]OKR-Periods of Words</a></li></ul><p>原理同上，如果有i一个公共前后缀长度为j，那么这个前缀i就有一个周期为i-j。</p><ul><li><a href="https://www.luogu.com.cn/problem/P4824">P4824 [USACO15FEB]Censoring (Silver)</a></li></ul><p>栈与KMP的结合。使用栈来寻找最长的匹配</p><ul><li><a href="https://www.luogu.com.cn/problem/P2375">P2375 [NOI2014]动物园</a></li></ul><p>利用题目性质与 $next$ 数组可递归 $O(n)$ 求解</p><h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3805">P3805 【模板】manacher算法</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P4555">P4555 [国家集训队]最长双回文串</a></li></ul><p>在记录以 $i$ 为对称轴的回文串半径时，可顺带记录以 $i$ 为首、尾的回文串长度，然后再转移。<br>因为回文串可能有重叠，下标的变化量注意为2。<br>学到两个新名词：饱和回文串，不饱和回文串。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.20模拟赛总结</title>
    <link href="/2021/08/20/8-20%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/20/8-20%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="*.pdf">题目</a></p><h3 id="T1-莓良心"><a href="#T1-莓良心" class="headerlink" title="T1  莓良心"></a>T1  莓良心</h3><p>学到了斯特林数的通项公式：</p><script type="math/tex; mode=display">\begin{Bmatrix}n\\k\end{Bmatrix}=\frac{1}{k!}×∑^{k}_{i=0}(-1)^i\dbinom{k}{i}(k-1)^n</script><h3 id="T2-尽梨了"><a href="#T2-尽梨了" class="headerlink" title="T2  尽梨了"></a>T2  尽梨了</h3><p>贪心出结论，再dp，dp时考虑去的店的个数的上界，便可进一步优化时间复杂度</p><h3 id="T3-团不过"><a href="#T3-团不过" class="headerlink" title="T3  团不过"></a>T3  团不过</h3><h3 id="T4-七负我"><a href="#T4-七负我" class="headerlink" title="T4  七负我"></a>T4  七负我</h3><p>学会了一种找最大团的方法：Bron–Kerbosch 算法<br>今后应该会写一篇笔记，毕竟新知识(++flag);</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.19训练计划&amp;记录</title>
    <link href="/2021/08/18/2021-8-19%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/18/2021-8-19%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><ul><li><a href="https://www.luogu.com.cn/problem/P3807">P3807 【模板】卢卡斯定理</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P5520">P5520 [yLOI2019]青原樱</a></li><li><a href="https://www.luogu.com.cn/problem/P3197">P3197 [HNOI2008]越狱</a></li></ul><p>插板法的应用</p><ul><li><a href="https://www.luogu.com.cn/problem/P2290">P2290 [HNOI2004]树的计数</a></li></ul><p>树上的组合数问题。<br>学到了一类数列: $prufur$ 数列</p><ul><li><a href="https://www.luogu.com.cn/problem/P4981">P4981 父子</a></li></ul><p>学到了一个公式: $Cayley$ 公式：  </p><blockquote><p>对于n个不同的节点，能够组成的无根树（原来是无向连通图或者是有标志节点的树）的种数是 $n^{n-2}$ 种</p></blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P1655">P1655 小朋友的球</a></li></ul><p>学到了斯特林数的状态转移方程</p><script type="math/tex; mode=display">f[i][j]=f[i-1][j-1]+f[i-1][j]\times j</script><ul><li><a href="https://www.luogu.com.cn/problem/P2532">P2532 [AHOI2012]树屋阶梯</a></li></ul><p>学到了卡特兰数的通项公式与递推式<br>通项公式： $h(n) = \frac{(2n)!}{(n+1)!̇⋅(n)!}$</p><p>递推式： $h(n)= Σ^{N-1}_{i=0}h(i)×h(N-i-1) (n≥2)$  </p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><ul><li><a href="https://www.luogu.com.cn/problem/P5664">P5664 Emiya 家今天的饭</a></li></ul><p>在dp过程中可以根据题目要求进行剪枝优化。<br>同时利用容斥，将不合法状态排除即可，将枚举范围缩小了一半以上</p><ul><li><a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008]硬币购物</a></li></ul><p>在背包容斥时可运用二进制子集枚举来简化<br>容斥应用在完全背包包括普通背包的情况，因此可进行容斥</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>排列组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷知乎小结</title>
    <link href="/2021/08/18/%E5%88%B7%E7%9F%A5%E4%B9%8E%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/08/18/%E5%88%B7%E7%9F%A5%E4%B9%8E%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Upd:2021-8-19</p><ol><li>“齐鲁方案”：指通过药物降低人体免疫反应以达到防止百草枯造成的肺部纤维化的疗法，因齐鲁医院提出并保持60%以上治愈率而闻名。<strong>百草枯并非无药可救！！！</strong></li></ol><hr><p>Upd:2021.8.18  </p><ol><li>“克强指数” ：原指经济指数可以造假，但用电量无法造假，因而得出结论：判断时应使用无法改变的硬性指标。<blockquote><p>e.g.婴幼儿出生率-&gt;母婴产品销售数据、疫苗接种数据，etc。</p></blockquote></li></ol><hr>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>知乎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-8-18训练计划&amp;记录</title>
    <link href="/2021/08/18/2021-8-18%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/18/2021-8-18%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.luogu.com.cn/problem/P1654">P1654 OSU!</a></li><li><a href="https://www.luogu.com.cn/problem/CF235B">CF235B Let’s Play Osu!</a></li></ul><p>两道为同一类型问题，都是求 $x^n$ 的期望的问题。<br>需要在dp时多维护一两个数组来记录非n次方项的值。</p><ul><li><a href="https://www.luogu.com.cn/problem/CF1042E">CF1042E Vasya and Magic Matrix</a></li></ul><p>学到了可以把期望转化成前缀和一类的式子。</p><ul><li><a href="https://www.luogu.com.cn/problem/P2634">P2634 [国家集训队]聪聪可可</a></li></ul><p>树形dp，与概率关系较小。学到了点分治与树形dp的转化</p><ul><li><a href="https://www.luogu.com.cn/problem/P6046">P6046 纯粹容器 senpai</a></li></ul><p>练习了在链上进行容斥的概率dp</p><ul><li><a href="https://www.luogu.com.cn/problem/CF453A">CF453A Little Pony and Expected Maximum</a></li></ul><p>分类讨论最大值的出现情况即可。<br>同时学到了一个结论： $P(X=K)=P(X≤K)−P(X≤K−1)$</p><ul><li><a href="https://www.luogu.com.cn/problem/CF16E">CF16E Fish</a></li></ul><p>dp时看到n的范围为 $n≤18$ 想到状压。同时这道题之前的状态会对之后的状态有影响，因此应采用倒推</p><ul><li><a href="https://www.luogu.com.cn/problem/CF280C">CF280C Game on Tree</a></li></ul><p>树上概率dp。考虑若要使一子树染黑，必要使一个祖先节点染黑（包括自己），因而节点 $i$ 被选中的概率为 $\frac{1}{dep[i]}$ 。</p><ul><li><a href="https://www.luogu.com.cn/problem/P6835">[Cnoi2020]线形生物</a></li></ul><p>用到了期望的线性性。学到随机游走类问题的状态构造方法：设 $E(i)$ 为到 $i$ 点的期望步数。</p><ul><li><a href="https://www.luogu.com.cn/problem/P6834">[Cnoi2020]梦原</a></li></ul><ol><li>树形期望问题一定要使用与父亲节点有关的信息。</li><li>区间查询满足条件的元素个数与和，且数据左端点单调不减，右端点单调递增时，可使用树状数组维护</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>概率期望</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-8-17训练计划&amp;记录</title>
    <link href="/2021/08/17/2021-8-17%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/17/2021-8-17%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="概率与期望"><a href="#概率与期望" class="headerlink" title="概率与期望"></a>概率与期望</h3><ul><li><a href="https://www.luogu.com.cn/problem/P1297">P1297 [国家集训队]单选错位</a></li><li><a href="https://www.luogu.com.cn/problem/P3802">P3802 小魔女帕琪</a></li><li><a href="https://www.luogu.com.cn/problem/P4550">P4550 收集邮票</a></li><li><a href="https://www.luogu.com.cn/problem/P1365">P1365 WJMZBMR打osu! / Easy</a></li></ul><p>基础题</p><ul><li><a href="https://www.luogu.com.cn/problem/P3750">P3750 [六省联考2017]分手是祝愿</a></li></ul><p>运用了每一个按键组合的不可替代性，使得dp可行</p><ul><li><a href="https://www.luogu.com.cn/problem/P3239">P3239 [HNOI2015]亚瑟王</a></li></ul><p>dp状态的设计：可使用两维，来记录前 $i$ 个中用了 $j$ 次的概率，进而可进行无后效性dp</p><ul><li><a href="https://www.luogu.com.cn/problem/P3232">P3232 [HNOI2013]游走</a></li><li><a href="https://www.luogu.com.cn/problem/P5249">P5249 [LnOI2019]加特林轮盘赌</a></li></ul><p>两题均需要对推出的方程组进行消元求解，应再看看高斯消元相关的知识</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>概率期望</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-8-16训练计划&amp;记录</title>
    <link href="/2021/08/15/2021-8-16%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/15/2021-8-16%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="概率与期望"><a href="#概率与期望" class="headerlink" title="概率与期望"></a>概率与期望</h3><blockquote><p><strong>期望是概率意义下的平均</strong></p></blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P5104">P5104 红包发红包</a></li></ul><p>概率dp入门</p><ul><li><a href="https://www.luogu.com.cn/problem/P1850">P1850 换教室</a>  </li></ul><p>考察了dp状态的设置。同时一个Floyd坑点的复习:读入边权时要与<code>INF</code>取个min。</p><ul><li><a href="https://www.luogu.com.cn/problem/P3830">P3830 [SHOI2012]随机树</a>  </li></ul><p>对“期望是概率意义下的平均”这句话有了更深的理解。<br>同时学会了一个公式：   </p><script type="math/tex; mode=display">f[i][j]=\sum^{i-1}_{L=1}p[i][L]\times\sum^{j}_{x=1}\sum^{j}_{y=1} f[L][j-1]\times f[i-L][y] (x==j-1 || y==j-1)</script><ul><li><a href="https://www.luogu.com.cn/problem/P4564">P4564 [CTSC2018]假面</a>  </li></ul><p>对于求无顺序背包的概率dp，可采用正序预处理后倒序操作的方法来降低时间复杂度。</p><ul><li><a href="https://www.luogu.com.cn/problem/P2473">P2473 [SCOI2008]奖励关</a>  </li></ul><p>状压dp与概率dp的结合。同样也运用了”期望是概率意义下的平均”的思想。</p><ul><li><a href="https://www.luogu.com.cn/problem/P2221">P2221 [HAOI2012]高速公路</a>  </li></ul><p>线段树，点权转边权，概率dp三者的结合。在使用线段树维护信息时，注意灵活拆分Σ符号，将其化为线段树可维护的信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>概率期望</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.14模拟赛总结</title>
    <link href="/2021/08/14/2021-8-14%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/14/2021-8-14%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="模拟赛.pdf">题目</a></p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>字符串的结论题：一个字符串的字典序最大字串一定是一个以最大字典序开头，非严格递减的最长字符串.<br>所以我们可以先正着找到字典序最大的字符，然后从后往前使用单调栈贪心，最后倒序输出即可。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>我们可以发现，理想情况下最小花费为</p><script type="math/tex; mode=display">Σ^{n-1}_{i}a_i\times a_{i-1}+min\{a_1,a_2,\ldots,a_n\}</script><p>可这都建立在 <script type="math/tex">a_{i-1}×a_{i}+a_{i}×a_{i+1}≤a_{i-1}×a_{i}×a_{i+1}</script> 的基础上的，而当这三个数中有一个 $1$ 时，等式便不成立了。<br>因此我们可将数列按 $1$ 的位置分为几块，在块内使用理想情况的式子贪心，最后加上 $1$ 的个数，便可得到答案。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://chenxizhou233.github.io/2021/08/14/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE/">见此页</a></p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>没有整明白，回来要抽时间看(flag++).<br><a href="https://www.luogu.com.cn/problem/P5616">[MtOI2019]恶魔之树(原题)</a><br><img src="T4.png" alt="题解"></p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>模拟赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路图</title>
    <link href="/2021/08/14/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE/"/>
    <url>/2021/08/14/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="最短路图"><a href="#最短路图" class="headerlink" title="最短路图"></a>最短路图</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>有这样一类题，它要求我们处理与一张图的多条最短路有关的问题，我们该如何解决呢？  </p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>对于这种情况，我们可以很自然地想到，我们可以对于所有最短路上的点重新建一个图，然后在新图中进行其它操作。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>我们可以先在原图上以1和 $n$ 为源点各跑一边单源最短路，记1到各点距离为 ${dis1}_1 , {dis1}_2 ,\ldots,{dis1}_n$ ,记 $n$ 点到各点距离为 ${dis2}_1,{dis2}_2,\ldots,{dis2}_n$ 。<br>然后遍历每个点 $i$ ，若 $dis1_i+dis2_i=dis1_n$ 则将该点加入最短路图中。最后得到的图便是最短路图。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge1[maxn],edge2[maxn];<span class="hljs-comment">//edge1为原图，edge2为重建的图</span><br><span class="hljs-type">int</span> dis1[maxn],dis2[maxn];<span class="hljs-comment">//与上文同义</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-comment">//n为点数</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis1[i]+dis2[i]==dis1[n])<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:edge1[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis1[p]+dis2[p]==dis1[n])<br>            edge2[i].<span class="hljs-built_in">emplace_back</span>(p);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>本蒟蒻才疏学浅，只知道一道，形式化描述如下：</p><blockquote><p>给定一张 N 个点M条边且边带权的无向图，你可以选择任意一条 S 到 T 之间的最短路径， 使得这条路径上的所有边权变为 0。求出进行修改之后，X 到 Y 之间路径长度的可能的最小值是多少。</p></blockquote><p>口胡答案如下：<br>对于本题来说，我们发现最优路径中一定为：一段X到Y的最短路，0边(可省略)，另一段X到Y的最短路。因此我们可以先对S、T、X、Y分别跑一遍单源最短路，然后再建立S-T的最短路图，并在其上dp，即可得出答案。<br>同时，对于这道题来说，我们关心两个值：X至最短路一点的距离，Y至最短路上另一点的距离，因此我们除了保留最短路上的点记为点集A，还需染色(在加点途中，若该点已有的颜色与邻点已有的颜色交集为空( $Color<em>i∩Color_j=∅$ )，计数器加一，并进行dfs染色。染色后的点集为 $C_1,C_2,\ldots,C</em>{cnt}$ (cnt为最短路个数))，可得dp式子为: </p><script type="math/tex; mode=display">f[x][y]=\min_{i,j∈C_k}^{1≤k≤cnt}{(f[x][i]+f[j][y],f[x][y])}</script><p>同时将 $f[x][y]$ 的初始值设为原图中两点最短路的值。最后的 $f[x][y]$ 即为答案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.12训练计划&amp;记录</title>
    <link href="/2021/08/12/2021-8-12%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/12/2021-8-12%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><h4 id="线性同余方程-amp-乘法逆元"><a href="#线性同余方程-amp-乘法逆元" class="headerlink" title="线性同余方程&amp;乘法逆元"></a>线性同余方程&amp;乘法逆元</h4><ul><li><a href="https://www.luogu.com.cn/problem/P4549">P4549 【模板】裴蜀定理</a></li><li><a href="https://www.luogu.com.cn/problem/P2613">P2613 【模板】有理数取余</a></li><li><a href="https://www.luogu.com.cn/problem/P3811">P3811 【模板】乘法逆元</a></li><li><a href="https://www.luogu.com.cn/problem/P5431">P5431 【模板】乘法逆元2</a>  </li><li><a href="https://www.luogu.com.cn/problem/P1082">P1082 同余方程</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P1516">P1516 青蛙的约会</a></li></ul><p>exgcd的简单运用</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><ul><li><a href="https://www.luogu.com.cn/problem/P4777">P4777 【模板】扩展中国剩余定理（EXCRT）</a>  </li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P4774">P4774 [NOI2018]屠龙勇士</a></li></ul><p>学到了对于带系数的EXCRT的处理方法：在处理的过程中将式子化为 $Ax+By=C$ 的形式，然后EXGCD。</p><ul><li><a href="https://www.luogu.com.cn/problem/P5345">P5345 【XR-1】快乐肥宅</a></li></ul><p>知道了新的结论: 一组数 $A\{a^k|k\in \mathbb{N} \}$ 模 $m$ 的完全剩余系会形成 $ρ$ 的形状,且循环节长度为 $\phi(m)$ 。<br>因此判断时可将其当作基环内向数来处理</p><h4 id="高次同余方程"><a href="#高次同余方程" class="headerlink" title="高次同余方程"></a>高次同余方程</h4><ul><li><a href="https://www.luogu.com.cn/problem/P4195">P4195 【模板】exBSGS</a></li><li><a href="https://www.luogu.com.cn/problem/P5491">P5491 【模板】二次剩余</a></li><li><a href="https://www.luogu.com.cn/problem/P2485">P2485 [SDOI2011]计算器</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P3306">P3306 [SDOI2013]随机数生成器</a></li></ul><p>将式子化简后，使用BSGS解决：  </p><ol><li><script type="math/tex; mode=display">X_{i+1}=aX_i+b\ (mod \ \ p)</script><script type="math/tex; mode=display">↓</script></li><li><script type="math/tex; mode=display">X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1}) \ (mod\ p)</script><script type="math/tex; mode=display">↓</script></li><li><script type="math/tex; mode=display">a^{n−1}≡(X_n+b∗inv(a−1))∗inv(X_1+b∗inv(a−1))\ (mod\ p)</script></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划，数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.11训练计划&amp;记录</title>
    <link href="/2021/08/10/2021-8-11%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/10/2021-8-11%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="整除相关"><a href="#整除相关" class="headerlink" title="整除相关"></a>整除相关</h3><h4 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h4><ul><li><a href="https://www.luogu.com.cn/problem/P4718">P4718 【模板】Pollard-Rho算法</a></li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P2441">P2441 角色属性树</a></li></ul><p>暴力可过，原理为在随机数据中，任取两数 $a,b$ , $gcd(a,b)&lt;1$ 的概率约为 $31\%$ ， 若为三个数，概率变为 $47\%$ , 四个时为 $55\%$ 。</p><ul><li><a href="https://www.luogu.com.cn/problem/P5535">P5535 【XR-3】小道消息</a></li></ul><p>结论题:<a href="https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704">伯特兰-切比雪夫定理</a><br>因此可得，答案必为1或2,分类讨论即可  </p><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><ul><li><a href="https://www.luogu.com.cn/problem/P5435">P5435 【模板】快速 GCD</a></li></ul><h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><ul><li><a href="https://www.luogu.com.cn/problem/P2568">P2568 GCD</a></li></ul><p>学会了一类化简：<br>$\sum^n_{a=1}\sum^n_{b=1,gcd(a,b)=1}→$<br>$\sum_p\sum_{a=1}^{\lfloor{\frac{n}{p}}\rfloor}\sum^{\lfloor{\frac{n}{p}}\rfloor}_{b=1,gcd(a,b)=1}1$  </p><ul><li><a href="https://www.luogu.com.cn/problem/P2398">P2398 GCD SUM</a></li></ul><p>对于整除分块的题，可处理出 $\phi(n)$ 的前缀和数组，进而加快运算效率</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.10训练计划&amp;记录</title>
    <link href="/2021/08/10/2021-8-10%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/10/2021-8-10%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><ul><li><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束算法</a>  </li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P3275">P3275 [SCOI2011]糖果</a>  </li></ul><ol><li>建图时需剪枝  </li><li><strong>开long long</strong></li></ol><ul><li><a href="https://www.luogu.com.cn/problem/P2294">P2294 [HNOI2005]狡猾的商人</a>  </li></ul><p>对于区间查询，可在前缀和上使用差分约束</p><ul><li><a href="https://www.luogu.com.cn/problem/P4926">P4926 [1007]倍杀测量者</a>  </li></ul><p>答案具有单调性，可以考虑使用差分约束二分</p><ul><li><a href="https://www.luogu.com.cn/problem/P5590">P5590 赛车游戏</a>  </li></ul><p>注意考虑图的连通性</p><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】缩点</a>  </li><li><a href="https://www.luogu.com.cn/problem/P3388">P3388 【模板】割点（割顶）</a>  </li></ul><p>模板题</p><ul><li><a href="https://www.luogu.com.cn/problem/P1407">P1407 [国家集训队]稳定婚姻</a>  </li></ul><p>常规缩点，同时，题目中的原图为无向图，因此，我们可规定夫妻M-&gt;F，情人F-&gt;M建边，便可使用Tarjian通过这道题。</p><ul><li><a href="https://www.luogu.com.cn/problem/P2515">P2515 [HAOI2010]软件安装</a>  </li></ul><p>缩点后，在新的图上树形dp<br>注意与<a href="https://www.luogu.com.cn/problem/P2746">Network of Schools</a>的区别：<br>Network of Schools是安装时必须按照先后关系，而这道题只关注最后是否满足依赖关系</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.8训练计划&amp;记录</title>
    <link href="/2021/08/09/2021-8-8%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/09/2021-8-8%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><blockquote><ul><li><p><a href="https://www.luogu.com.cn/problem/P3384">P3384 【模板】树链剖分</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2590">P2590 [ZJOI2008]树的统计</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3258">P3258 [JLOI2014]松鼠的新家</a></p></li></ul></blockquote><h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h4><blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P3313">P3313 [SDOI2014]旅行</a></li></ul></blockquote><p>学会了在空间紧张的时候将动态开点线段树与树链剖分组合</p><blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P2486">P2486 [SDOI2011]染色</a></li></ul></blockquote><p>学会了维护树上一段的信息，合并与处理：<br>如求链上整段个数，可在维护pos1与pos2时将颜色也维护上</p><blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P4069">P4069 [SDOI2016]游戏</a></li></ul></blockquote><p>观察到这道题要求的是形如 $y=kx+b$ 的式子，因此考虑使用李超线段树来维护最值</p><blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P4211">P4211 [LNOI2014]LCA</a></li></ul></blockquote><p>由最初的暴力求(每次暴力求lca)-&gt;优化(将询问按右端点排序，并使用差分减少时间复杂度)<br>学会了将树链上的询问可重复贡献问题排序后使用差分解决</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>图论</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦纳树学习笔记</title>
    <link href="/2021/08/07/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/07/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="斯坦纳树——从费马点开始"><a href="#斯坦纳树——从费马点开始" class="headerlink" title="斯坦纳树——从费马点开始"></a>斯坦纳树——从费马点开始</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>相信大家在日常学习生活中都遇到过这个问题：求三角形的<a href="https://zhuanlan.zhihu.com/p/136600079">费马点</a>。相信大家对此并不陌生，结论也显而易见。可若将它推广开来，求平面内一点，使其到给定的n个点的距离和最小，那么还有开箱即用的结论吗？这就是我们今天要探讨的问题：斯坦纳树了  </p><span id="more"></span><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>有了三个点的情况，我们自然而然地便会将问题推广至n个点： </p><blockquote><p>形式化描述：<br>给定点 <script type="math/tex">A_1,A_2,\ldots,A_n</script> ,求一点P,使得 <script type="math/tex">Σ^n_{i=1}PA_i</script>最小  </p></blockquote><p>这个推广看起来很好，但<em>库朗（R.Courant）和罗宾斯（H.Robbins）提出第一个定义的推广是肤浅的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="OIwiki-斯坦纳树">[1]</span></a></sup></em>,因此，在OI中，我们要研究的问题就变为了：给定 $n$ 个点 $A_1,A_2,\ldots,A_n$ ,试求连接这 $n$ 个点的最短线段总和。  </p><p>初看是不是特别像最小生成树？但请注意，在斯坦纳网络中，两个关键点之间并不一定要直接相连。如图：<br><img src="steiner-tree1.png" alt="P1"><br>可以看到，每张图中都会有一些红色的中转点。但在一些情况下，也可能会退化为蓝点。<br>就像费马点一样，大多数时候，我们都需要找中转点。  </p><p>在图论中，点的位置被进一步确定，因此问题被进一步转化为：给定 $n$ 个节点，其中有 $k$ 个关键点，求一个子图使所有关键点联通且边权最小。</p><blockquote><p>其实这有点像最小生成树的Prim算法，不过S，T两个点集转移时只在点集中添加关键点</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>知道了这些后，我们便可开始写代码了。解决这类组合最优化问题，我们可以使用状压dp的思想，记 $f(i,S)$ 为当前子树根为 $i$ 时,子树内关键点联通的最小代价。 </p><blockquote><p>为什么是“树”呢？我们可以反证：若有环，则删去后总边权值】必定减小，因此一定更优，所以最后形成的图一定是树  </p></blockquote><h3 id="P6192-【模板】最小斯坦纳树-边权"><a href="#P6192-【模板】最小斯坦纳树-边权" class="headerlink" title="P6192 【模板】最小斯坦纳树(边权)"></a><a href="https://www.luogu.com.cn/problem/P6192">P6192 【模板】最小斯坦纳树</a>(边权)</h3><p>这道题有两个要点：一是子集的枚举，二是状态的转移；<br>观察dp式子：  </p><p>对于 $i$ 的度数为 $1$ 的情况，可以考虑枚举树上与 $i$ 相邻的点 $j$，则：</p><script type="math/tex; mode=display">f(j,S)+w(j,i)\to f(i,S)</script><p>对于 $i$ 的度数大于 $1$ 的情况，可以划分成几个子树考虑，即：</p><script type="math/tex; mode=display">f(i,T)+f(i,S-T)\to f(i,S)\ \ (T\subseteq S)</script><p>其中，对于第二个式子，由于满足三角形不等式，因此可以使用dijkstra优化</p><h3 id="修复长城-点权"><a href="#修复长城-点权" class="headerlink" title="修复长城(点权)"></a><a href="http://61.139.95.227:82/problem/342">修复长城</a>(点权)</h3><p>本题只需在建边时将点权转化为边权后，便可采用同样的思路通过这道题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://oi-wiki.org/graph/steiner-tree/">OIwiki-斯坦纳树</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021.8.7模拟赛总结</title>
    <link href="/2021/08/07/2021-8-7%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/07/2021-8-7%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="T1-序列"><a href="#T1-序列" class="headerlink" title="T1 序列"></a>T1 序列</h3><p><img src="T1.png" alt="T1"><br>构造一棵平衡树，使其支持反转与查询排名的操作。<br>本蒟蒻的做法为使用FHQ-Treap并将 $key$ 换为当前节点的高度,便可通过此题  </p><h3 id="T2-跨年晚会"><a href="#T2-跨年晚会" class="headerlink" title="T2 跨年晚会"></a>T2 跨年晚会</h3><p><img src="T2.png" alt="T2"><br>贪心  </p><h3 id="T3-数星星"><a href="#T3-数星星" class="headerlink" title="T3 数星星"></a>T3 数星星</h3><p><img src="T3.png" alt="T3"><br>容斥原理，今后要多做些这样的题  </p><h3 id="T4-修复长城"><a href="#T4-修复长城" class="headerlink" title="T4 修复长城"></a>T4 修复长城</h3><p><img src="T4.png" alt="T4"><br>这应该算一道斯坦纳树的板子题，日后应该会写笔记  </p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>模拟赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1492D</title>
    <link href="/2021/08/07/CF1492D/"/>
    <url>/2021/08/07/CF1492D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定三个数 $a,b,k$ 要求构造出两个数 $x,y$ ( $x&gt;y$ )使:<br>1: $x$ 与 $y$ 的二进制表达中有 $a$ 个 $0$ ， $b$ 个 $1$<br>2: $x-y$ 的结果的二进制表达中有 $k$ 个 $1$<br><strong>$x,y$ 的二进制表示中不能有前导零</strong>  </p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>三个整数 $a,b,k$ ; </p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出”Yes”或”No”<br>若有解，输出两行二进制数表示一种可能的 $x$ 与 $y$ 的组合  </p><hr><span id="more"></span><p>显然，这是一道构造题<br>观察样例我们可以发现，形如:   </p><blockquote><p>$1…1000…0$<br>$1…0001…0$  </p></blockquote><p>的数，在相减后必定会产生<strong>中间的$0$的个数</strong>个$1$ 。<br>但样例中没有给出 $a&lt;k$ 且成立的情况<br>所以我们还要考虑中间的 $0$ 不够 $k$ 个的情况。<br>再次观察上面的例子，发现中间的 $0$ 只做<strong>占位</strong>作用，只要那一位的二进制数相减为 $0$ ,就是合法的构造。因此只需在构造时在中间部分补 $1$ 就行了。<br>因为题目要求<strong>结果中不能有前导零</strong>，所以还要注意特判一下出现前导零的情况。<br>我的代码有较多特判与不优美的输出方式，但逻辑较为清晰，大家可酌情查看。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">int</span> a, b, k;<br><span class="hljs-type">int</span> tmp1, tmp2;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;k);<br>    <span class="hljs-comment">//若结果里没有1，那至少原数要有1个1</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> &amp;&amp; b != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">//a+b-2&lt;k其实等价于判断a+b&lt;=k+1</span><br>    <span class="hljs-comment">//如k！=0且只有1个1，那么因为不能有前导零，</span><br>    <span class="hljs-comment">//所以像&quot;100&quot;,&quot;001&quot;就是错误的构造</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a + b - <span class="hljs-number">2</span> &lt; k || k != <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//结果有1，但x,y中无0,显然不行</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &amp;&amp; !a)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <span class="hljs-comment">//0够不够，分情况讨论</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt;= k)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a - k; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a - k; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a + b - k - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k - a; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a + b - k - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k - a; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris遍历</title>
    <link href="/2021/08/07/Morris%E9%81%8D%E5%8E%86/"/>
    <url>/2021/08/07/Morris%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Morris遍历，-O-1-空间遍历二叉树"><a href="#Morris遍历，-O-1-空间遍历二叉树" class="headerlink" title="Morris遍历， $O(1)$ 空间遍历二叉树"></a>Morris遍历， $O(1)$ 空间遍历二叉树</h1><p>在我们的学习过程中，二叉树的前、中、后序遍历相信大家并不陌生了：dfs一下就行了。<br>但，在最坏情况下,整颗二叉数都会被存入栈空间中。<br>为了解决这种问题，我们便引入了一种新的遍历方式：Morris遍历  </p><blockquote><p>注意，这只是一种实现前、中、后序遍历的方式，并不是一种新的遍历规则   </p></blockquote><span id="more"></span><h2 id="原理讲解："><a href="#原理讲解：" class="headerlink" title="原理讲解："></a>原理讲解：</h2><p>在整个过程中，我们需要维护<strong>当前节点的位置cur</strong>与cur的<strong>左子树中最右端的节点pre</strong>，并利用一些节点的右儿子的<strong>空余的指针</strong>，使得我们能够建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次来保证 $O(1)$ 的空间复杂度的。下面我们通过伪代码来讲解这一过程<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">cur = root;<span class="hljs-comment">//cur初始化为根结点</span><br><span class="hljs-keyword">while</span>(cur!=null)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cur.left==null) cur=cur.right;<span class="hljs-comment">//如果左子树为空，将当前节点更新为右子树根结点</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        pre = <span class="hljs-built_in">getPre</span>(cur.left);<span class="hljs-comment">//找到cur左子树中最右边的节点  </span><br>        <span class="hljs-keyword">if</span>(pre.right==null)<br>            pre.right = cur;<br>            <span class="hljs-comment">//注意，这里是Morris遍历的核心部分，它利用了空余的资源，将“存放根结点”的任务无需额外空间便完成了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre.right==cur)<br>            pre.right = null;<br>            <span class="hljs-comment">//还原树结构（回溯）</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>我们可以发现，这个算法的核心就是利用<strong>空闲的叶子节点的右指针</strong>来减少空间复杂度的<br>下面我们通过一张图来解释一下这个过程：<br><img src="20200216151818405.png" alt="简单的二叉树"></p><ul><li>将根节点1设置为cur。</li><li>因为cur（节点1）不为空，且cur（节点1）的左孩子节点2不为空，所以我们找到以节点2为根节点的左子树中最右端的节点5。</li><li>节点5右孩子为空，此时我们输出cur（节点1）的值，然后将节点5右孩子指向为cur，即节点1。更新cur节点为cur左孩子，即节点2。</li><li>因为cur（节点2）左孩子不为空，找到其左子树最右端节点4</li><li>节点4右孩子为空，先输出cur（节点2）的值，再将节点4右孩子指向cur（节点2）,并更新cur（节点2）为其左孩子节点4。</li><li>这个时候cur（节点4）的左孩子为空，所以访问其右孩子，发现右孩子指向了节点2，所以我们将cur更新为节点2。</li><li>这个时候我们发现cur又指向了节点2，所以左孩子节点4不为空，我们再次找到左子树中最右端节点4，但是这个时候节点4的右孩子指向了cur，所以我们将其删除，即节点4右孩子指向为空，恢复原来的树结构。并且由于已经访问了左孩子和根节点，所以这个时候我们访问其右孩子节点5。</li><li>……  <h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MorrisPreOrderTraverse</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>Node *cur = root;<br>Node *pre = <span class="hljs-literal">NULL</span>;<br> <br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre = cur-&gt;left;<br><span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(pre-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;right != cur)<br>&#123;<br>pre = pre-&gt;right;<br>&#125;<br><span class="hljs-keyword">if</span> (pre-&gt;right == <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre-&gt;right = cur;<span class="hljs-comment">// 空闲指针</span><br>cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">// 打印结点值的顺序稍微调整</span><br>cur = cur-&gt;left;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre-&gt;right = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cur = cur-&gt;right;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MorrisInOrderTraverse</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>Node *cur = root;<br>Node *pre = <span class="hljs-literal">NULL</span>;<br> <br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre = cur-&gt;left;<br><span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(pre-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;right != cur)<br>&#123;<br>pre = pre-&gt;right;<br>&#125;<br><span class="hljs-keyword">if</span> (pre-&gt;right == <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre-&gt;right = cur;<span class="hljs-comment">// 空闲指针</span><br>cur = cur-&gt;left;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre-&gt;right = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cur = cur-&gt;right;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">reverseEdge</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>Node *pre = <span class="hljs-literal">NULL</span>;<br>Node *next = <span class="hljs-literal">NULL</span>;<br> <br><span class="hljs-keyword">while</span>(root != <span class="hljs-literal">NULL</span>)<br>&#123;<br>next = root-&gt;right;<br>root-&gt;right = pre;<br>pre = root;<br>root = next;<br>&#125;<br> <br><span class="hljs-keyword">return</span> pre;<br>&#125;<br> <br><span class="hljs-comment">// 逆序打印左子树右边界</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>Node *lastNode = <span class="hljs-built_in">reverseEdge</span>(root);<br>Node *cur = lastNode;<br> <br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cur = cur-&gt;right;<br>&#125;<br><span class="hljs-built_in">reverseEdge</span>(lastNode);<br>&#125;<br> <br><span class="hljs-comment">// Morris后序遍历 (左 -&gt; 右 -&gt; 根)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MorrisPostOrderTraverse</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>Node *cur = root;<br>Node *pre = <span class="hljs-literal">NULL</span>;<br> <br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre = cur-&gt;left;<br><span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(pre-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;right != cur)<br>&#123;<br>pre = pre-&gt;right;<br>&#125;<br><span class="hljs-keyword">if</span> (pre-&gt;right == <span class="hljs-literal">NULL</span>)<br>&#123;<br>pre-&gt;right = cur;<span class="hljs-comment">// 空闲指针</span><br>cur = cur-&gt;left;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre-&gt;right = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">printEdge</span>(cur-&gt;left);<br>&#125;<br>&#125;<br>cur = cur-&gt;right;<br>&#125;<br><span class="hljs-built_in">printEdge</span>(root);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>感谢以下博客，为本文提供了资料<br>1.<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/xiang-jie-cshi-xian-morriszhong-xu-bian-li-jie-fa-/">遍历的c++实现</a>   </p><ol><li><a href="https://blog.csdn.net/danmo_wuhen/article/details/104339630">图源侵删</a>  </li></ol><p>感谢以下博客，帮助我更好的理解。<br>1.<a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris</a><br>2.<a href="https://blog.csdn.net/weixin_42638946/article/details/118788173">Morris遍历</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
